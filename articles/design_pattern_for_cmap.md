---
title: "GoFのデザインパターン"
emoji: "👻"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["デザインパターン", "typescript"]
published: false
---

<!-- GOFのデザインパターン23種類の中からCareerMapに適用すると良さそうなパターンを例として3つ上げる				 -->

# デザインパターンとは
一番代表的なものが、GoFの23個のデザインパターン。
(GoF = Gang of Four : 著者の4人)

GoF以外のものもある。下記はそれを紹介しているページ。
https://www.hyuki.com/dp/dpinfo.html

# GoFのデザインパターン (23個)

## 生成に関するパターン (5個)

### Factory Method（工場メソッド）パターン ☆4
  実際に生成するオブジェクトに依存しない、オブジェクト生成のインタフェースを提供します。

  浦島太郎も金太郎も、createPair()と呼べば旅のお供がそれぞれ別についてくる。
  https://xtech.nikkei.com/it/article/COLUMN/20051202/225609/?i_cid=nbpnxt_reco_atype
  
  ##### 背景・課題
  
  ##### 方法・効果

### Abstract Factory（抽象的な工場）パターン ☆5
  互いに関連する一連のオブジェクト郡を、その具象クラスに依存しないで生成するためのインタフェースを提供します。

  https://xtech.nikkei.com/it/article/COLUMN/20051202/225609/?i_cid=nbpnxt_reco_atype
  
  ##### 背景・課題
  
  ##### 方法・効果

### Builder（構築者）パターン ☆5
  複合化されたオブジェクトについて、その生成過程を隠蔽することにより、同じ過程で異なる内部形式のオブジェクトを生成できます。

  ##### 背景・課題
  
  ##### 方法・効果
  生成時の状態（オブジェクトが持つフィールドの初期値）が異なるオブジェクトを生成する「ビルダクラス」と「ディレクタクラス」を用意。
  ビルダクラスは職人で、ディレクタクラスは現場監督。

### Prototype（原型）パターン ☆5
  原型となるオブジェクトを元に複製します。
  ##### 背景・課題
  
  ##### 方法・効果
  自分のクローンを作るメソッドをクラスの中に用意しておく。


- Singleton パターン
  あるオブジェクトが単一であること（複数オブジェクト生成されていないこと）を保証します。

## 構造に関するパターン (7個)

### Adapter（接続装置）パターン ☆5
  互換性のないインタフェースを持つクラス同士の接続を可能にします。

  社員クラスを引数にした給与計算メソッドに対して、社長クラスを集約して保有しており、かつ社員クラスを継承したアダプタクラスを作って、それを給与計算メソッドに渡すことで、社長の給与計算も同じメソッドで、かつ給与計算メソッドと社長クラスに変更を加えることなく、社長の給与計算ができる。

  ##### 背景・課題
  
  ##### 方法・効果
  
  アンチパターンな気がするが、これを深ぼるかはあとで判断。
  https://xtech.nikkei.com/it/article/COLUMN/20051201/225566/?i_cid=nbpnxt_reco_atype


- Bridge パターン
  あるクラスにおける機能拡張と実装を分離し、それらを独立して管理します。
- Composite パターン
  個々のオブジェクトと合成したオブジェクトを同一視することにより、再帰的な構造を表現します。
- Decorator パターン
  ある核(コア)となるオブジェクトに、動的な機能追加を提供します。

### Facade（見かけ）パターン ☆5
  複数のサブシステムの統一窓口となる高レベルなインタフェースを提供します。
  
  ##### 背景・課題
  
  ##### 方法・効果
  複数のクラスのメソッドを使って1つの機能が実現されている。
  その機能を使う側のクラスにその複数のクラスを呼び出させるのでなく、複数のクラスを呼び出す役割のFacadeクラスを作って、それを使うようにする。

- Flyweight パターン
  多数のオブジェクトの中で同じものと見なせるオブジェクトを共有し、オブジェクトの構築のための負荷を減らします。
- Proxy パターン
  あるオブジェクトへのアクセスを制御するため、共通のインタフェースを持つオブジェクトが代理をします。

## 振る舞いに関するパターン (11個)
- Interpreter パターン
  文法規則をクラスで表現したものを用い構文解析し、その結果に基づき処理を実行していく機能を提供します。

- Template Method パターン
  スーパークラスで処理の流れを定義し、その処理の詳細はサブクラスで定義します。

### Chain of Responsibility（責任の連鎖）パターン 4
  複数のオブジェクトを鎖状につなぎ、その中の任意のオブジェクトがある要求を処理するまで、順次その鎖に沿って要求を受流していきます。
  ##### 背景・課題
  
  ##### 方法・効果
  他のオブジェクトに処理を依頼。（委譲）

- Command パターン
  命令・操作をクラス(オブジェクト)で表現し、そのオブジェクトを切り替えることで操作の切り替えを実現します。

### Iterator（繰り返し）パターン ☆5
  集約オブジェクトを内包するオブジェクトが内部表現を公開することなく、その要素に順にアクセスする方法を提供します。

  ##### 背景・課題
  オブジェクトAが、オブジェクトBの持つ配列データを参照して、それをループで呼び出して使う。こういう場合、AはBのことを知りすぎている。
  そのBのデータが配列であることが前提のコードになっているため、そのBのデータ構造が変わったらAにも改修が必要になってしまう。
  ##### 方法・効果
  オブジェクトの持つデータ構造を非公開にして、代わりに、hasNext()とnext()という2つのメソッドだけを公開する。
  hasNext()は、まだ取得されていないデータが残っていればtrueを返し、残ってないならfalseを返す。next()は、順番にデータを取得して返す。
  オブジェクトAからオブジェクトBに、hasNext()で「データありますか？」と質問し、答えがtrueならnext()で「データください」と要求する。

### Mediator（調停者）パターン ☆5
  オブジェクト同士が互いに参照し合うことがないように、仲介役となるオブジェクトを介して制御を行う方法を提供します。
  
  ##### 背景・課題
  複数のオブジェクトを組み合わせて機能を作るという性質上、オブジェクト間の関連がゴチャゴチャになる問題がある。
  オブジェクトA, B, C, Dが互いに関連を持っている（= 他のオブジェクトの持つメソッドを呼び出している）とき、どれかを改造しようとしたら他に影響を与えてしまうため、変更が困難になる。
  ##### 方法・効果
  オブジェクト同士が互いに参照し合うことがないように、仲介役となるオブジェクトを介して制御することで、オブジェクト同士の関連を整理できる。
  オブジェクトA~Dは、他のオブジェクトを参照するとき、それらの調停者（仲介役）となるオブジェクトMを介して参照するようにする。そうすることで、A~Dに発生した変更の影響はMだけで済む。


- Memento パターン
  データ構造に対するその箇所箇所の操作内容・状態を記録しておき、以前の状態の復帰、操作の再実行を行えるようにします。

- Observer パターン
  あるオブジェクトの変化を、それに依存するオブジェクトに自動的に知らせる仕組みを提供します。

- State パターン
  状態を表すオブジェクトを用意し、内包するその状態オブジェクトを切り替えることにより、処理内容(振る舞い)を変えられるようにします。

- Strategy パターン
  一連のアルゴリズム(戦略)をカプセル化(部品化)し、動的なアルゴリズムの切替えを可能とします。

- Visitor パターン
  データ構造を表すクラスと、それに対する処理を行うクラスを分離します。(データ構造を表すクラスを変更することなしに処理を追加できます。)





# 参考ページ
https://www.techscore.com/tech/DesignPattern/
http://www.itsenka.com/contents/development/designpattern/
https://refactoring.guru/ja/design-patterns/typescript