---
title: "GoFのデザインパターン"
emoji: "👻"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["デザインパターン", "typescript"]
published: false
---

<!-- GOFのデザインパターン23種類の中からCareerMapに適用すると良さそうなパターンを例として3つ上げる				 -->

# デザインパターンとは
ソフトウェアの設計をする上でよく起きる問題の典型的な解決方法。
先人が見つけた良い方法を整理したパターン集。

一番代表的なものが、GoFの23個のデザインパターン。(GoF = Gang of Four : 著者の4人)
例えば[こちら](https://www.hyuki.com/dp/dpinfo.html)にあるように、GoF以外のものもある。


# GoFのデザインパターン
全23パターンあるが、それらは大きく3つの分類に分けられる。
- 生成に関するパターン (5個)
- 構造に関するパターン (7個)
- 振る舞いに関するパターン (11個)


## 生成に関するパターン
オブジェクトを生成する仕組みに関するもの。

| パターン名 | 概要・何が嬉しいのか |
| :-: | - |
| Factory Method<br>（工場） | **生成するオブジェクト**(`製品`)**に依存しない、オブジェクト生成のインタフェース**(`工場`の持つ`生産メソッド`)**を提供する**。<br>つまり、色々な種類がある製品のどれを作るときでも、それを作る工場に共通の生産メソッドで依頼すれば作ってくれる。<br>（`Template Method`のインスタンス生成特化ver.）<br><br>乗用車工場にもトラック工場にも`createCar()`と依頼すればそれぞれの製品を作ってくれる。そして作られた車には各製品で異なるビジネスロジックであっても、共通して`deliver("東京")`と依頼できる。<br>こうなると、新たにタクシーを作る必要が出ても、生産メソッドやその製品のできること（メソッド）が他の製品と同じなので、**簡単に製品を追加できる**。 |
| [Abstract Factory](https://github.com/ito0804takuya/design-pattern_typescript/tree/main/src/abstract_factory)<br>(抽象的な工場) |  |
| [Builder](https://github.com/ito0804takuya/design-pattern_typescript/tree/main/src/builder)<br>(構築者) |  |
| Prototype<br>（原型） | 原型となるオブジェクトを元に複製する。つまり、**原型となるオブジェクト(のみ)が自身の複製方法を知っている**。<br><br>自分のクローンを作るメソッド`clone()`をPrototypeインターフェースに用意しておく。<br>そのインターフェースを実装するPrototypeクラスには、自身のインスタンスを複製するのに必要な手続きを`clone()`に実装する。<br><br>別のオブジェクトがオブジェクトを複製しようとする場合、その複製するオブジェクトのことをよく知っていないといけないため、そこに依存関係が生まれる。複製されるオブジェクト自身が複製方法を持つことで、その依存関係を解消できる。 |
| Singleton<br>(一人っ子) | クラスが**1つのインスタンスしか持たない**ことを保証する。<br><br>インスタンス生成の方法を外部に公開してはいけないため、コンストラクタをprivateにする。インスタンス生成時に既にインスタンスが存在しているのかチェックする。 |


## 構造に関するパターン
  クラスの構造に関するもの。

| パターン名 | 説明 |
| :-: | - |
| Adapter<br>(接続装置) | **互換性のないインタフェースを持つクラス同士の接続を可能にする**。<br><br>クライアントが使う側のクラスのインターフェースに合わせたアダプターを作る。もう片方のクラスとうまく変換できるように、アダプター内でそのインターフェースに合わせて実装する。 |
| Bridge<br>（橋） | あるクラスにおける**抽象部と実装部を分離**することで、管理・拡張しやすくする。<br><br>組み合わせて使用される2つのオブジェクト（例：リモコンとデバイス）が現状1つの一枚岩クラスになっているとして、それら各々に多彩な種類がある場合、それらの組み合わせは膨大に膨れ上がる。そういったときの拡張（組み合わせ）をどう実現するかという話。<br>1つになっているクラスをリモコン（抽象化層）とデバイス（実装）に分ける。リモコンクラスにデバイスを参照するフィールドを設けて、デバイスにはインターフェースを用意することで、リモコン・デバイスがそれぞれ独自に多品種開発できる。 |
| Composite（合成物） | **個々のオブジェクト と それら複数から成る階層構造を持ったオブジェクト を同一視**することにより、**再帰的な構造を表現する**。<br><br>オブジェクト単体では、単に自己完結型で処理を行うよう実装。<br>合成オブジェクトでは、単体オブジェクトにメソッドを実行させて、その後、次に処理すべきオブジェクトがあれば再帰的にメソッドを呼び出す。<br><br>このオブジェクトを使う側は、それが多くの階層を持っているのか、それとも下階層が無い単一のものなのかを気にせず呼び出せる。 |
| [Decorator](https://github.com/ito0804takuya/design-pattern_typescript/tree/main/src/decorator)<br>（装飾者） |  |
| [Facade](https://github.com/ito0804takuya/design-pattern_typescript/tree/main/src/facade)<br>（見かけ） |  |
| Flyweight<br>（軽量級） | 多数のオブジェクトの中で同じものと見なせるオブジェクトを共有し、オブジェクトの構築のための負荷を減らす。 <br>要は、**キャッシュしたいプロパティはFlyweightクラスとして保持**しておいて、**頻繁に（動的に）変化するプロパティはContextクラスとして切り出し**、全体での**メモリ（RAM）使用量を減らそう**という試み。 |
| [Proxy](https://github.com/ito0804takuya/design-pattern_typescript/tree/main/src/proxy)<br>（代理人） |  |


## 振る舞いに関するパターン
  オブジェクト感の責任の分担に関するもの。

| パターン名 | 説明 |
| :-: | - |
| Interpreter（通訳）| 文法規則をクラスで表現したものを用い構文解析し、その結果に基づき処理を実行していく機能を提供します。滅多に必要とされないパターン。|
| Template Method（ひな型メソッド） |  |
| Chain of Responsibility（責任の連鎖） | 複数のオブジェクトを鎖状につなぎ、その中の任意のオブジェクトがある要求を処理するまで、順次その鎖に沿って要求を受流していきます。他のオブジェクトに処理を依頼。（委譲） |
| Command（命令） | 命令・操作をクラス(オブジェクト)で表現し、そのオブジェクトを切り替えることで操作の切り替えを実現します。注文メソッドの引数に、具体的な具材・調理方法を渡すのでなく、作ってほしい料理名を渡す。 |
| Iterator（繰り返し） | 集約オブジェクトを内包するオブジェクトが内部表現を公開することなく、その要素に順にアクセスする方法を提供します。
    ##### 背景・課題
    オブジェクトAが、オブジェクトBの持つ配列データを参照して、それをループで呼び出して使う。こういう場合、AはBのことを知りすぎている。
    そのBのデータが配列であることが前提のコードになっているため、そのBのデータ構造が変わったらAにも改修が必要になってしまう。
    ##### 方法・効果
    オブジェクトの持つデータ構造を非公開にして、代わりに、hasNext()とnext()という2つのメソッドだけを公開する。
    hasNext()は、まだ取得されていないデータが残っていればtrueを返し、残ってないならfalseを返す。next()は、順番にデータを取得して返す。
    オブジェクトAからオブジェクトBに、hasNext()で「データありますか？」と質問し、答えがtrueならnext()で「データください」と要求する。
|
| Mediator（調停者） | オブジェクト同士が互いに参照し合うことがないように、仲介役となるオブジェクトを介して制御を行う方法を提供します。
    
    ##### 背景・課題
    複数のオブジェクトを組み合わせて機能を作るという性質上、オブジェクト間の関連がゴチャゴチャになる問題がある。
    オブジェクトA, B, C, Dが互いに関連を持っている（= 他のオブジェクトの持つメソッドを呼び出している）とき、どれかを改造しようとしたら他に影響を与えてしまうため、変更が困難になる。
    ##### 方法・効果
    オブジェクト同士が互いに参照し合うことがないように、仲介役となるオブジェクトを介して制御することで、オブジェクト同士の関連を整理できる。
    オブジェクトA~Dは、他のオブジェクトを参照するとき、それらの調停者（仲介役）となるオブジェクトMを介して参照するようにする。そうすることで、A~Dに発生した変更の影響はMだけで済む。
|
| Memento（形見） | データ構造に対するその箇所箇所の操作内容・状態を記録しておき、以前の状態の復帰、操作の再実行を行えるようにします。（railsでいうと、change_カラム名みたいなメソッドがしていることが似ている。） |
| Observer（観察者） | あるオブジェクトの変化を、それに依存するオブジェクトに自動的に知らせる仕組みを提供します。通知先のクラス（オブジェクト）に、（インターフェースによって）通知を送信するメソッドの実装を強制。通知元クラスは、通知先が複数あろうが、通知先を格納した配列にそのメソッドをループ処理すれば、複数の通知先に簡単に通知できる。(railsでいうと、after_saveとかか。)



## 生成に関するパターン (5個)
### Abstract Factory（抽象的な工場）パターン
  互いに関連する一連のオブジェクト郡を、その具象クラスに依存しないで生成するためのインタフェースを提供します。

  https://xtech.nikkei.com/it/article/COLUMN/20051202/225609/?i_cid=nbpnxt_reco_atype
  
  **候補**
  **募集のエントリー、企業実習のエントリー、説明会のエントリーをしたときに生成されてほしいエントリー、メッセージ、活動記録が異なるはずなので、こういう感じで使えそう。**

### Builder（構築者）パターン
  複合化されたオブジェクトについて、その生成過程を隠蔽することにより、同じ過程で異なる内部形式のオブジェクトを生成できます。

  生成時の状態（オブジェクトが持つフィールドの初期値）が異なるオブジェクトを生成する「ビルダクラス」と「ディレクタクラス」を用意。
  ビルダクラスは職人で、ディレクタクラスは現場監督。

  **候補**
  **募集のエントリー、企業実習のエントリー、説明会のエントリーをしたときに生成されてほしいエントリー、メッセージ、活動記録が異なるはずなので、こういう感じで使えそう。**
  **↑のAbstract Factoryとどちらかを使うことになりそう。どっち使えばいいかわからん。**

---

## 構造に関するパターン (7個)
### Decorator（装飾者）パターン
  ある核(コア)となるオブジェクトに、動的な機能追加を提供します。

  継承を使わずとも、既存クラスのメソッド+αの機能を持ったメソッドを実装できる。
  新しいクラスのメソッドの中から、その既存クラスのメソッドを呼び出すことで実現。

  **候補**
  **メッセージ、メール、slack通知の組み合わせを自在に作れそう**

### Facade（見かけ）パターン
  複数のサブシステムの統一窓口となる高レベルなインタフェースを提供します。
  
  複数のクラスのメソッドを使って1つの機能が実現されている。
  その機能を使う側のクラスにその複数のクラスを呼び出させるのでなく、複数のクラスを呼び出す役割のFacadeクラスを作って、それを使うようにする。

  **候補**
  **これは便利。確定かな**

### Proxy（代理人）パターン
  あるオブジェクトへのアクセスを制御するため、共通のインタフェースを持つオブジェクトが代理をします。

  Proxy（代理人）パターンは、オブジェクトに送られるメッセージ（メソッド呼び出し）をフック（横取り）して任意の処理を挿入するための工夫。
  
  （どういう構造なのかは分かったが、どう使うのかが分からなかった）

  **候補**
  **これは便利。確定かな**

---

## 振る舞いに関するパターン (11個)

### Template Method（ひな型メソッド）パターン
  スーパークラスで処理の流れを定義し、その処理の詳細はサブクラスで定義します。

  いくつかのメソッド（処理）を呼び出すメソッド（処理の流れを定義）を、ひな型として定義したクラスを作成。それを継承したクラスでその処理の流れを定義したメソッドの具体的な内容を実装する。

  **候補**
  **色々な種類のcsvを作る工程をテンプレート化できる。**


### State（状態）パターン ☆4
  状態を表すオブジェクトを用意し、内包するその状態オブジェクトを切り替えることにより、処理内容(振る舞い)を変えられるようにします。

  状態を表す複数のクラスを作る。
  
  **候補**
  **メッセージとか募集情報の下書き、応募の進捗などで使えそう**

### Strategy（戦略）パターン ☆3
  一連のアルゴリズム(戦略)をカプセル化(部品化)し、動的なアルゴリズムの切替えを可能とします。

  あることをするのに、いくつかの方法（ロジック）がある場合、その方法クラスを複数作り、それを行うクラスはその方法クラスを選択することでアルゴリズムを切り替えできる。

  **候補**
  **検索に対して、企業or学校or学生or事務局かのロールごとの戦略として使えそう**

### Visitor（訪問者）パターン
  データ構造を表すクラスと、それに対する処理を行うクラスを分離します。(データ構造を表すクラスを変更することなしに処理を追加できます。)

  データ構造を持つクラス（受け入れ）のメソッドの引数に、機能を持つクラス（訪問者）を渡す形にすることで、前者の受け入れクラスの中で訪問者が仕事をするようになる。そうなると、訪問者クラスを変更することで、受け入れクラスにほとんど変更せずに機能を追加・変更できる。

  （jobに切り出したり、concernとかinteractionに切り出しているのがイメージとしては近いか。）

  *候補**
  *複雑度が高いとのことだったのでこれはやめた。**


# 参考ページ
https://www.techscore.com/tech/DesignPattern/
http://www.itsenka.com/contents/development/designpattern/
https://refactoring.guru/ja/design-patterns/typescript