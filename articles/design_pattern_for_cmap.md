---
title: "GoFのデザインパターン"
emoji: "👻"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["デザインパターン", "typescript"]
published: false
---

<!-- GOFのデザインパターン23種類の中からCareerMapに適用すると良さそうなパターンを例として3つ上げる				 -->

# デザインパターンとは
一番代表的なものが、GoFの23個のデザインパターン。
(GoF = Gang of Four : 著者の4人)

GoF以外のものもある。下記はそれを紹介しているページ。
https://www.hyuki.com/dp/dpinfo.html

# GoFのデザインパターン (23個)

## 生成に関するパターン (5個)

### Factory Method（工場メソッド）パターン ☆4
  実際に生成するオブジェクトに依存しない、オブジェクト生成のインタフェースを提供します。

  浦島太郎も金太郎も、createPair()と呼べば旅のお供がそれぞれ別についてくる。
  https://xtech.nikkei.com/it/article/COLUMN/20051202/225609/?i_cid=nbpnxt_reco_atype
  
  ##### 背景・課題
  
  ##### 方法・効果

### Abstract Factory（抽象的な工場）パターン ☆5
  互いに関連する一連のオブジェクト郡を、その具象クラスに依存しないで生成するためのインタフェースを提供します。

  https://xtech.nikkei.com/it/article/COLUMN/20051202/225609/?i_cid=nbpnxt_reco_atype
  
  ##### 背景・課題
  
  ##### 方法・効果

### Builder（構築者）パターン ☆5
  複合化されたオブジェクトについて、その生成過程を隠蔽することにより、同じ過程で異なる内部形式のオブジェクトを生成できます。

  ##### 背景・課題
  
  ##### 方法・効果
  生成時の状態（オブジェクトが持つフィールドの初期値）が異なるオブジェクトを生成する「ビルダクラス」と「ディレクタクラス」を用意。
  ビルダクラスは職人で、ディレクタクラスは現場監督。

### Prototype（原型）パターン ☆5
  原型となるオブジェクトを元に複製します。
  ##### 背景・課題
  
  ##### 方法・効果
  自分のクローンを作るメソッドをクラスの中に用意しておく。


### Singleton（一人っ子）パターン ☆3
  あるオブジェクトが単一であること（複数オブジェクト生成されていないこと）を保証します。


## 構造に関するパターン (7個)

### Adapter（接続装置）パターン ☆5
  互換性のないインタフェースを持つクラス同士の接続を可能にします。

  社員クラスを引数にした給与計算メソッドに対して、社長クラスを集約して保有しており、かつ社員クラスを継承したアダプタクラスを作って、それを給与計算メソッドに渡すことで、社長の給与計算も同じメソッドで、かつ給与計算メソッドと社長クラスに変更を加えることなく、社長の給与計算ができる。

  ##### 背景・課題
  
  ##### 方法・効果
  
  アンチパターンな気がするが、これを深ぼるかはあとで判断。
  https://xtech.nikkei.com/it/article/COLUMN/20051201/225566/?i_cid=nbpnxt_reco_atype


### Bridge（橋）パターン ☆3
  あるクラスにおける機能拡張と実装を分離し、それらを独立して管理します。
  ##### 背景・課題
  
  ##### 方法・効果
  親クラスA（スーパークラス）の中の抽象メソッドがあり、その子クラス（サブクラス）にそれを実装したメソッドがある場合、クラスAを拡張したクラスBを作って抽象メソッドを実装して内容は同じメソッドを作成するには、その子クラスの実装は継承できないため、クラスBでも子クラスを作って実装する必要がある。

  - クラスA
    - 抽象メソッド
  - Aの子クラス
    - クラスAを継承
    - 抽象メソッドを実装
  - クラスB
    - クラスAを継承
  - Bの子クラス
    - クラスBを継承
    - 抽象メソッドを実装

  下記のように変更する。
  - クラスA
    - メソッド（抽象メソッドからメソッドに変更）
    - インターフェースを作成
  - Aの子クラス
    - インターフェースを実装
  - クラスB
    - クラスAを継承 → 抽象メソッドでなく、メソッドになっているため、メソッドをそのまま継承できる → クラスBの子クラスを作らずとも、Aの子クラスが実装した内容をそのまま利用できる。





- Composite パターン
  個々のオブジェクトと合成したオブジェクトを同一視することにより、再帰的な構造を表現します。

### Decorator（装飾者）パターン
  ある核(コア)となるオブジェクトに、動的な機能追加を提供します。

  ##### 背景・課題
  
  ##### 方法・効果
  継承を使わずとも、既存クラスのメソッド+αの機能を持ったメソッドを実装できる。
  新しいクラスのメソッドの中から、その既存クラスのメソッドを呼び出すことで実現。

### Facade（見かけ）パターン ☆5
  複数のサブシステムの統一窓口となる高レベルなインタフェースを提供します。
  
  ##### 背景・課題
  
  ##### 方法・効果
  複数のクラスのメソッドを使って1つの機能が実現されている。
  その機能を使う側のクラスにその複数のクラスを呼び出させるのでなく、複数のクラスを呼び出す役割のFacadeクラスを作って、それを使うようにする。

### Flyweight（軽量級）パターン ☆5
  多数のオブジェクトの中で同じものと見なせるオブジェクトを共有し、オブジェクトの構築のための負荷を減らします。

  社員の数が1000人であっても、役職の数は社長、専務、部長、課長、主任、担当の6種類だけだとしましょう。最初にShainクラスのオブジェクトを6つだけロードし、それぞれのyakushokuフィールドだけを設定しておきます。shimeiフィールドに設定するデータは、必要に応じてファイルから読み出せばよいのです
  （ちょっとよく分かっていない。ファイルとは何？DB？そんなことしたらN+1発生するが？）

- Proxy パターン
  あるオブジェクトへのアクセスを制御するため、共通のインタフェースを持つオブジェクトが代理をします。

## 振る舞いに関するパターン (11個)
- Interpreter パターン
  文法規則をクラスで表現したものを用い構文解析し、その結果に基づき処理を実行していく機能を提供します。

- Template Method パターン
  スーパークラスで処理の流れを定義し、その処理の詳細はサブクラスで定義します。

### Chain of Responsibility（責任の連鎖）パターン 4
  複数のオブジェクトを鎖状につなぎ、その中の任意のオブジェクトがある要求を処理するまで、順次その鎖に沿って要求を受流していきます。
  ##### 背景・課題
  
  ##### 方法・効果
  他のオブジェクトに処理を依頼。（委譲）

- Command パターン
  命令・操作をクラス(オブジェクト)で表現し、そのオブジェクトを切り替えることで操作の切り替えを実現します。

### Iterator（繰り返し）パターン ☆5
  集約オブジェクトを内包するオブジェクトが内部表現を公開することなく、その要素に順にアクセスする方法を提供します。

  ##### 背景・課題
  オブジェクトAが、オブジェクトBの持つ配列データを参照して、それをループで呼び出して使う。こういう場合、AはBのことを知りすぎている。
  そのBのデータが配列であることが前提のコードになっているため、そのBのデータ構造が変わったらAにも改修が必要になってしまう。
  ##### 方法・効果
  オブジェクトの持つデータ構造を非公開にして、代わりに、hasNext()とnext()という2つのメソッドだけを公開する。
  hasNext()は、まだ取得されていないデータが残っていればtrueを返し、残ってないならfalseを返す。next()は、順番にデータを取得して返す。
  オブジェクトAからオブジェクトBに、hasNext()で「データありますか？」と質問し、答えがtrueならnext()で「データください」と要求する。

### Mediator（調停者）パターン ☆5
  オブジェクト同士が互いに参照し合うことがないように、仲介役となるオブジェクトを介して制御を行う方法を提供します。
  
  ##### 背景・課題
  複数のオブジェクトを組み合わせて機能を作るという性質上、オブジェクト間の関連がゴチャゴチャになる問題がある。
  オブジェクトA, B, C, Dが互いに関連を持っている（= 他のオブジェクトの持つメソッドを呼び出している）とき、どれかを改造しようとしたら他に影響を与えてしまうため、変更が困難になる。
  ##### 方法・効果
  オブジェクト同士が互いに参照し合うことがないように、仲介役となるオブジェクトを介して制御することで、オブジェクト同士の関連を整理できる。
  オブジェクトA~Dは、他のオブジェクトを参照するとき、それらの調停者（仲介役）となるオブジェクトMを介して参照するようにする。そうすることで、A~Dに発生した変更の影響はMだけで済む。


- Memento パターン
  データ構造に対するその箇所箇所の操作内容・状態を記録しておき、以前の状態の復帰、操作の再実行を行えるようにします。

### Observer（観察者）パターン ☆4
  あるオブジェクトの変化を、それに依存するオブジェクトに自動的に知らせる仕組みを提供します。
  ##### 背景・課題

  ##### 方法・効果
  通知先のクラス（オブジェクト）に、（インターフェースによって）通知を送信するメソッドの実装を強制。
  通知元クラスは、通知先が複数あろうが、通知先を格納した配列にそのメソッドをループ処理すれば、複数の通知先に簡単に通知できる。

### State（状態）パターン ☆4
  状態を表すオブジェクトを用意し、内包するその状態オブジェクトを切り替えることにより、処理内容(振る舞い)を変えられるようにします。
  ##### 背景・課題

  ##### 方法・効果
  状態を表す複数のクラスを作る。

- Strategy パターン
  一連のアルゴリズム(戦略)をカプセル化(部品化)し、動的なアルゴリズムの切替えを可能とします。

- Visitor パターン
  データ構造を表すクラスと、それに対する処理を行うクラスを分離します。(データ構造を表すクラスを変更することなしに処理を追加できます。)





# 参考ページ
https://www.techscore.com/tech/DesignPattern/
http://www.itsenka.com/contents/development/designpattern/
https://refactoring.guru/ja/design-patterns/typescript