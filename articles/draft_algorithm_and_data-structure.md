---
title: "問題解決力を鍛える アルゴリズムとデータ構造"
emoji: "🔥"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["アルゴリズム", "データ構造"]
published: false
---

https://www.kspub.co.jp/book/detail/5128442.html

# 1 章 アルゴリズムとは

問題を解くための手順・方法。

- 線形探索
- 2 分探索
- 深さ優先探索
  とりあえず突き進み、行き詰まったら戻って次の選択肢を試す。
- 幅優先探索
  現地点から近いところをすべて順に探索する。（深さでなく幅を優先。）
- マッチング

# 2 章 計算量とオーダー記法

## オーダー記法

**計算時間がおおむね P(N)に比例する** ということを、 `O( P(N) )` と表す。
そのアルゴリズムの計算量は、`O(P(N))`である という。

オーダー記法において、低次の項（最高次以外の項）や 係数 は無視する。
これは、`N`が大きなときにそれらがほとんど影響しなくなる（関係なくなる）ため。

$$
例えば、3N^2 + 2N + 100 は N^2とする
$$

また、この文脈で対数`log`が出てくるとき、その底は（暗黙的に）`2`である。

## 計算量

- 時間計算量 : 計算に必要な時間を表す。（本書内で 計算量 という場合はこちらを指す。）
- 領域計算量 : 計算に必要なメモリ量を表す。

# 3 章 設計技法(1)：全探索

部分和問題の解法として、ビット演算を用いる手法がある。（詳細は省略。）
（再帰関数を用いる方法もあるが、4 章で紹介。）

# 4 章 設計技法(2)：再帰と分割統治法

## 再帰

```go:再帰
package main

import "fmt"

// 階乗を求める
// 引数nに負の値が来ると無限ループになるため、下記実装はNG。あくまでサンプル
func factorial(n int) int {
  if n == 1 {
    return 1
  }
  return n * factorial(n-1)
}

func main() {
  fmt.Println(factorial(4)) // -> 12
}
```

最初に呼び出すのは`factorial(4)`だが、**最初に値を返すのは**（1 を返す）**`factorial(1)`**。（最後に値を返すのは`factorial(4)`。）

再帰関数は、大体の場合は下記の構造になっている。
ベースケースとは、再帰を呼び出さない条件のこと。「最初に返す値として、**どんな値からその再帰は実行を始めればいいのか**」を考えるといい。

```go
func(引数) {
  if (ベースケース) {
    return 値
  }

  func(次の引数)
  return 答え
}
```

:::message alert
膨大な回数の再帰は、（スタック領域を使うため）メモリを消費するので注意。
:::

## ユークリッドの互除法

ユークリッドの互除法で、簡単に 2 つの数値の最大公約数を求めることができる。

:::message

1. **2 つの数値 m, n** 同士を割った**余りを r** とする

$$
m / n = x + r
$$

2. r == 0 なら、n が最大公約数
3. r != 0 なら、m = n , n = r として 1.に戻る
   :::

```go:ユークリッドの互除法
package main

import "fmt"

func calculateMaxPledges(m int, n int) int {
  if m%n == 0 {
    return n
  } else {
    return calculateMaxPledges(n, m%n)
  }
}

func main() {
  m, n := 51, 15
  fmt.Println("最大公約数は", calculateMaxPledges(m, n))
}
```

## フィボナッチ数列
フィボナッチ数列は再帰を使うと計算量が`O(N^2)`になる。
（前にも計算したのと同じ計算を毎度行ってしまうため）

単にforループで、前の2つ数値を足し合わせたほうがよい。`O(N)`
```go:forループ
package main

import "fmt"

func main() {
  fibo_count := 50
  // fibo_countを使って配列要素数を指定できない。動的であるため。
  // その場合は配列とは違い要素数が動的なスライスを使うことになる。今回は配列で実施。
  fibos := [50]int{0, 1} // 初期値として1つ目のフィボナッチ数は0, 2つ目は1をセット。

  // 上で1, 2つ目のフィボナッチ数は用意したため、3つ目からループで計算する
  for i := 2; i < fibo_count; i++ {
    fibos[i] = fibos[i-1] + fibos[i-2]
  }
  fmt.Println(fibos)
}
```

再帰を使う場合は、前に計算した値をメモ化して、計算済みであればそれを返す方法がある。（キャッシュの考え方）



4.4 メモ化して動的計画法へ
4.5 再帰の例(3)：再帰関数を用いた全探索
4.6 分割統治法
4.7 まとめ

5 章 設計技法(3)：動的計画法
5.1 動的計画法とは
5.2 最初の例題
5.3 動的計画法に関連する諸概念
5.4 動的計画法の例(1)：ナップサック問題
5.5 動的計画法の例(2)：編集距離
5.6 動的計画法の例(3)：区間分割の仕方を最適化
5.7 まとめ

6 章 設計技法(4)：二分探索法
6.1 配列の二分探索
6.2 C++の std::lower bound()
6.3 一般化した二分探索法
6.4 さらに一般化した二分探索法
6.5 応用例(1)：年齢当てゲーム
6.6 応用例(2)：std::lower bound() の活用例
6.7 応用例(3)：最適化問題を判定問題に
6.8 応用例(4)：メディアンを求める
6.9 まとめ

7 章 設計技法(5)：貪欲法
7.1 貪欲法とは
7.2 貪欲法が最適解を導くとは限らないこと
7.3 貪欲法パターン(1)：交換しても悪化しない
7.4 貪欲法パターン(2)：現在がよいほど未来もよい
7.5 まとめ

8 章 データ構造(1)：配列、連結リスト、ハッシュテーブル
8.1 データ構造を学ぶ意義
8.2 配列
8.3 連結リスト
8.4 連結リストの挿入操作と削除操作
8.5 配列と連結リストの比較
8.6 ハッシュテーブル
8.7 まとめ

9 章 データ構造(2)：スタックとキュー
9.1 スタックとキューの概念
9.2 スタックとキューの動作と実装
9.3 まとめ

10 章 データ構造(3)：グラフと木
10.1 グラフ
10.2 グラフの例
10.3 グラフの実装
10.4 重み付きグラフの実装
10.5 木
10.6 順序木と二分木
10.7 二分木を用いるデータ構造の例(1)：ヒープ
10.8 二分木を用いるデータ構造の例(2)：二分探索木
10.9 まとめ

11 章 データ構造(4)：Union-Find
11.1 Union-Find とは
11.2 Union-Find の仕組み
11.3 Union-Find の計算量を削減する工夫
11.4 Union-Find の工夫その 1：union by size
11.5 Union-Find の工夫その 2：経路圧縮
11.6 Union-Find の実装
11.7 Union-Find の応用：グラフの連結成分の個数
11.8 まとめ

12 章 ソート
12.1 ソートとは
12.2 ソートアルゴリズムの良し悪し
12.3 ソート(1)：挿入ソート
12.4 ソート(2)：マージソート
12.5 ソート(3)：クイックソート
12.6 ソート(4)：ヒープソート
12.7 ソートの計算量の下界
12.8 ソート(5)：バケットソート
12.9 まとめ

13 章 グラフ(1)：グラフ探索
13.1 グラフ探索を学ぶ意義
13.2 深さ優先探索と幅優先探索
13.3 再帰関数を用いる深さ優先探索
13.4 「行きがけ順」と「帰りがけ順」
13.5 最短路アルゴリズムとしての幅優先探索
13.6 深さ優先探索と幅優先探索の計算量
13.7 グラフ探索例(1)：s-t パスを求める
13.8 グラフ探索例(2)：二部グラフ判定
13.9 グラフ探索例(3)：トポロジカルソート
13.10 グラフ探索例(4)：木上の動的計画法
13.11 まとめ

14 章 グラフ(2)：最短路問題
14.1 最短路問題とは
14.2 最短路問題の整理
14.3 緩和
14.4 DAG 上の最短路問題：動的計画法
14.5 単一始点最短路問題：ベルマン・フォード法
14.6 単一始点最短路問題：ダイクストラ法
14.7 全点対間最短路問題：フロイド・ワーシャル法
14.8 参考：ポテンシャルと差分制約系
14.9 まとめ

15 章 グラフ(3)：最小全域木問題
15.1 最小全域木問題とは
15.2 クラスカル法
15.3 クラスカル法の実装
15.4 全域木の構造
15.5 クラスカル法の正当性
15.6 まとめ

16 章 グラフ(4)：ネットワークフロー
16.1 ネットワークフローを学ぶ意義
16.2 グラフの連結度
16.3 最大流問題と最小カット問題
16.4 フォード・ファルカーソン法の実装
16.5 応用例(1)：二部マッチング
16.6 応用例(2)：点連結度
16.7 応用例(3)：プロジェクト選択問題
16.8 まとめ

17 章 P と NP
17.1 問題の難しさの測り方
17.2 P と NP
17.3 P ≠ NP 予想
17.4 NP 完全
17.5 多項式時間帰着の例
17.6 NP 困難
17.7 停止性問題
17.8 まとめ

18 章 難問対策
18.1 NP 困難問題との対峙
18.2 特殊ケースで解ける場合
18.3 貪欲法
18.4 局所探索と焼きなまし法
18.5 分枝限定法
18.6 整数計画問題への定式化
18.7 近似アルゴリズム
18.8 まとめ
