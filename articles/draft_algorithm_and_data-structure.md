---
title: "問題解決力を鍛える アルゴリズムとデータ構造"
emoji: "🔥"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["アルゴリズム", "データ構造"]
published: false
---

https://www.kspub.co.jp/book/detail/5128442.html

# 1 章 アルゴリズムとは

問題を解くための手順・方法。

- 線形探索
- 2 分探索
- 深さ優先探索
  とりあえず突き進み、行き詰まったら戻って次の選択肢を試す。
- 幅優先探索
  現地点から近いところをすべて順に探索する。（深さでなく幅を優先。）
- マッチング

# 2 章 計算量とオーダー記法

## オーダー記法

**計算時間がおおむね P(N)に比例する** ということを、 `O( P(N) )` と表す。
そのアルゴリズムの計算量は、`O(P(N))`である という。

オーダー記法において、低次の項（最高次以外の項）や 係数 は無視する。
これは、`N`が大きなときにそれらがほとんど影響しなくなる（関係なくなる）ため。

$$
例えば、3N^2 + 2N + 100 は N^2とする
$$

また、この文脈で対数`log`が出てくるとき、その底は（暗黙的に）`2`である。

## 計算量

- 時間計算量 : 計算に必要な時間を表す。（本書内で 計算量 という場合はこちらを指す。）
- 領域計算量 : 計算に必要なメモリ量を表す。

# 3 章 設計技法(1)：全探索

部分和問題の解法として、ビット演算を用いる手法がある。（詳細は省略。）
（再帰関数を用いる方法もあるが、4 章で紹介。）

# 4 章 設計技法(2)：再帰と分割統治法

## 再帰

```go:再帰
package main

import "fmt"

// 階乗を求める
// 引数nに負の値が来ると無限ループになるため、下記実装はNG。あくまでサンプル
func factorial(n int) int {
  if n == 1 {
    return 1
  }
  return n * factorial(n-1)
}

func main() {
  fmt.Println(factorial(4)) // -> 12
}
```

最初に呼び出すのは`factorial(4)`だが、**最初に値を返すのは**（1 を返す）**`factorial(1)`**。（最後に値を返すのは`factorial(4)`。）

再帰関数は、大体の場合は下記の構造になっている。
ベースケースとは、再帰を呼び出さない条件のこと。「最初に返す値として、**どんな値からその再帰は実行を始めればいいのか**」を考えるといい。

```go
func(引数) {
  if (ベースケース) {
    return 値
  }

  func(次の引数)
  return 答え
}
```

:::message alert
膨大な回数の再帰は、（スタック領域を使うため）メモリを消費するので注意。
:::

## ユークリッドの互除法

ユークリッドの互除法で、簡単に 2 つの数値の最大公約数を求めることができる。

:::message

1. **2 つの数値 m, n** 同士を割った**余りを r** とする

$$
m / n = x + r
$$

2. r == 0 なら、n が最大公約数
3. r != 0 なら、m = n , n = r として 1.に戻る
   :::

```go:ユークリッドの互除法
package main

import "fmt"

func calculateMaxPledges(m int, n int) int {
  if m%n == 0 {
    return n
  } else {
    return calculateMaxPledges(n, m%n)
  }
}

func main() {
  m, n := 51, 15
  fmt.Println("最大公約数は", calculateMaxPledges(m, n))
}
```

## フィボナッチ数列

フィボナッチ数列は再帰を使うと計算量が`O(N^2)`になる。
（前にも計算したのと同じ計算を毎度行ってしまうため）

単に for ループで、前の 2 つ数値を足し合わせたほうがよい。`O(N)`

```go:forループ
package main

import "fmt"

func main() {
  fibo_count := 50
  // fibo_countを使って配列要素数を指定できない。動的であるため。
  // その場合は配列とは違い要素数が動的なスライスを使うことになる。今回は配列で実施。
  fibos := [50]int{0, 1} // 初期値として1つ目のフィボナッチ数は0, 2つ目は1をセット。

  // 上で1, 2つ目のフィボナッチ数は用意したため、3つ目からループで計算する
  for i := 2; i < fibo_count; i++ {
    fibos[i] = fibos[i-1] + fibos[i-2]
  }
  fmt.Println(fibos)
}
```

:::message
再帰を使う場合は、**前に計算した値をメモ化**して、**計算済みであればそれを返す**方法がある。（キャッシュの考え方）
:::

## 部分和問題

N 個の数字から何個かを選んで、総和を x にできるか という問題。
再帰でも実装できるが、計算量が最悪`O(2^N)`なので効率的でない。

# 5 章 設計技法(3)：動的計画法

## 動的計画法

動的計画法とは、
問題を**一連の部分問題に分解**し、
**各部分問題の解をメモ化**しながら、
**小さな問題から大きな問題へ**と順に解を求めていく手法。
（抽象度の高い話）

## Flog 問題

カエルが「次の足場に行く」or「（1 つ飛ばしで）2 つ先の足場に行く」を選びながら、足場の落差（移動コスト）が最小になる方法で移動したときの総落差を求める という問題。

```go:Flog問題
package main

import (
  "fmt"
  "math"
)

func abs(n int) int {
  return int(math.Abs(float64(n)))
}

func min(a int, b int) int {
  return int(math.Min(float64(a), float64(b)))
}

func flog(steps []int) int {
  // コスト[0] = 0
  // コスト[1] = 頂点0から1step = コスト[0] + |頂点0 - 頂点1|
  // コスト[2] = min[ 頂点1から1step, 頂点0から2step ] = min[ コスト[1] + |頂点1 - 頂点2| , コスト[0] + |頂点0 - 頂点2| ]
  // コスト[3] = min[ 頂点2から1step, 頂点1から2step ] = min[ コスト[2] + |頂点2 - 頂点3| , コスト[1] + |頂点1 - 頂点3| ]
  // コスト[4] = ...

  // 入力であるsteps（スライス）と同じ数の配列をmake()で作成
  dp := make([]int, len(steps))
  dp[0] = 0 // 初期値

  for i := 1; i < len(steps); i++ {
    if i == 1 {
      dp[i] = abs(steps[i] - steps[i-1])
    } else {
      dp[i] = min(dp[i-1]+abs(steps[i]-steps[i-1]), dp[i-2]+abs(steps[i]-steps[i-2]))
    }
  }

  return dp[len(dp)-1]
}

func main() {
  steps := []int{2, 9, 4, 5, 1, 6, 10} // 足場の高さ
  fmt.Println(flog(steps))
}
```

## ナップサック問題

重さ w、価値 v が決まっている N 個の品物の中から、重さの総和が W を超えように選んだときの、価値の最大値を求める問題。

まず、総価値 dp の初期値は `dp[0][w] = 0`。
それ以降、i 番目の品物を選んだときの総価値 `dp[i][w]` が決まっている状態で、`dp[i+1][w]`を求めて、i+1 番目の品物を選択して総価値が高まったかどうかを調べる。
そうして、その品物を選ぶ or 選ばないという 2 択を順に判断していく。

```go
package main

import (
  "fmt"
)

type Item struct {
  Weight int
  Value  int
}

func chmax(a *int, b int) {
  if *a < b {
    *a = b
  }
}

func maxValue(items []Item, maxWeight int) int {
  // value[i][w] : 重さ w 以内に収まる中で、i 番目の品物を選んだときの総価値
  // 必要な要素数が格納できる2次元配列を作る。（各要素の値はすべて0）
  value := make([][]int, len(items)+1)
  for i := range value {
    value[i] = make([]int, maxWeight+1)
  }

  for i, item := range items {
    for w := 0; w <= maxWeight; w++ {
      if w-item.Weight >= 0 {
        // 制限値 w 以内の品物なので、その品物を選ぶ可能性を検討する。
        // その品物を選ばなかったときの価値 vs 選んだときの価値 で高い方を、
        // 制限値w・i番目までの品物における最大価値として、valueにメモする。
        chmax(&value[i+1][w], value[i][w-item.Weight]+item.Value)
      }
      // 制限値wを超える品物なのでその品物自体は選ばない。ただ、そのことをvalueにメモはする。
      chmax(&value[i+1][w], value[i][w])
    }
  }

  // 2次元配列の末尾の要素が、戦いに勝ち抜いた[最大価値]なので、それを返す。
  return value[len(items)][maxWeight]
}

func main() {
  // 品物（重さ, 価値）
  items := []Item{
    {Weight: 2, Value: 3},
    {Weight: 1, Value: 2},
    {Weight: 3, Value: 6},
    {Weight: 2, Value: 1},
    {Weight: 1, Value: 3},
    {Weight: 5, Value: 85},
  }

  // fmt.Println(maxValue(items, 5)) // 重さの制限を5にしたときの最大価値
  // fmt.Println(maxValue(items, 10))
  fmt.Println(maxValue(items, 15))
}
```

# 6 章 設計技法(4)：二分探索法

二分探索法は、アルゴリズムのことだけを指すのでなく、より汎用的な考え方。
例えば、プログラムのデバッグのとき、バグの発生箇所を二分探索的に特定していく作業が有効。

# 7 章 設計技法(5)：貪欲法

貪欲法とは、 1 ステップ先だけを考えて最善を選択し、それを繰り返す方法。
:::message alert
貪欲法が最適解を導くとは限らないことに注意。
:::
貪欲法が有効になる状況というのは、その問題自体が良い構造をしていることが多い。

# 8 章 データ構造(1)：配列、連結リスト、ハッシュテーブル

データ構造とは、**データの持ち方**のこと。

- 配列
- 連結リスト
- ハッシュテーブル
  連想配列（Ruby で言う Hash）は、ハッシュテーブルの実装。

# 9 章 データ構造(2)：スタックとキュー

- スタック : 積読本のイメージ。最後に積んだものを取っていく。
- キュー : 筒のイメージ。最初に入ったものが（筒の先から）出てくる。

# 10 章 データ構造(3)：グラフと木

## グラフとは

対象物の関係性を表すもの。
対象物を**頂点**（vertex）と呼び、線を**辺**（edge）と呼ぶ。

グラフ G は、頂点の集合 V、辺の集合 E の組として定義され、`G = (V, E)`と表す。
1 つの辺 e は、2 つの頂点 vi, vj の組として定義され、`e = (vi, vj)`と表す。

頂点 vi, vj が辺 e によって結ばれているとき、
vi と vj は**隣接**しているといい、vi, vj は**e の端点**という。

```
             辺 e
頂点 vi --------------- 頂点 vj
```

#### 重み付きグラフとは

各頂点に*重み*を付けたグラフのこと。

#### 有向グラフとは

辺に向きがあるグラフのこと。（その逆は無向グラフ。）

#### 部分グラフとは

グラフ G の中にすっぽり収まるグラグ G'のこと。

また、ウォーク、サイクル、パスは、部分グラフの 1 種。

- 部分グラフ
  - **ウォーク**
    2 つの頂点 s, t に対して、隣接する頂点を辿って s から t へ到達できるとき、その経路を s-t ウォークという。
    - **サイクル**
      ウォークのうち、始点と終点が等しいもの。
    - **パス**
      ウォークのうち、同じ頂点を 2 回以上通らないもの。
      s-t パスが存在するとき、そのグラフ G は**連結**であるという。

（ウォーク、サイクル、パスの）**長さ**とは、「重み付きグラフの場合は**各辺の重みの総和**」、「重みなしグラフの場合は**辺の総本数**」を表す。

#### グラフの実装

有向グラフの場合、グラフ自体の実装は下記のような感じ。

````go
package main

import "fmt"

// 入力は下記のように与えられると想定。
// ```
// N(頂点数) M(辺数)
// a0 b0 (0番目の辺が、頂点a0と頂点b0を結ぶ)
// a1 b1
//  ~  ~
// a[M-1] b[M-1]
// ```

func main() {
  var n, m int
  fmt.Scan(&n, &m)

  g := make([][]int, n)

  for i:= 0; i < m; i++ {
    var a, b int
    fmt.Scan(&a, &b)

    g[a] = append(g[a], b)
  }

  // gは、i番目の頂点が他のどの頂点に向かう辺があるか というグラフとなっている。（この例は有向グラフのため）
  fmt.Println(g) // [[5 2] [3 6] [5 7] [0 7] [1 2 6] [] [7] [0]]
}
````

## 木とは

**連結で、かつサイクルを持たない**グラフのこと。

#### 根付き木とは

特定の 1 つの頂点を特別扱いした**根**（root）を持つ木のこと。
根 と ある頂点 v を結ぶパスの長さを、v の**深さ**と呼ぶ。（根の深さは 0。）
深さの最大値のことは、木の**高さ**と呼ぶ。

#### 順序木とは

ある頂点の子頂点に順序がある木のこと。
子頂点同士は兄弟関係になる。

#### 二分木とは

子頂点が 2 つしかない木のこと。

根付き木の構造をもつデータ構造では、多くの場合、計算量が`O(h)`となる。
h は木の高さなので、**左右への辺の伸び方が均等であるほど、有用なものとなる**。
左右の辺の高さが等しい場合、頂点数 N として高さは`O(logN)`となる。

#### ヒープとは

各頂点に**キー**と呼ばれる値を持つ二分木のこと。

# 11 章 データ構造(4)：Union-Find

（一旦飛ばす）

11.1 Union-Find とは
11.2 Union-Find の仕組み
11.3 Union-Find の計算量を削減する工夫
11.4 Union-Find の工夫その 1：union by size
11.5 Union-Find の工夫その 2：経路圧縮
11.6 Union-Find の実装
11.7 Union-Find の応用：グラフの連結成分の個数
11.8 まとめ

# 12 章 ソート
ソートアルゴリズムには、クイックソートなど色々な種類のものがある。

ソートアルゴリズムの良し悪しは、以下の尺度で評価される。
1. 計算量
2. 追加で必要な外部メモリ容量（in place性）
  外部のメモリを必要とするかどうか。（ソートする配列に使っている以外のメモリ容量が必要か。）
3. 安定ソートかどうか（安定性）
  2つ以上の同一値を含んでいる配列をソートしたその前後で、それらの同一値の順序関係が保たれるかどうか。


#### 挿入ソート
「左（配列の先頭側）からi番目の要素までがソートされている状態から、i+1番目の要素までがソートされている状態にする」という考え方のソート。
```go:挿入ソート
package main

import "fmt"

func insertionSort(arr []int) []int {
	// 配列の1つ目の要素arr[0]はソートの必要が無いため、2つ目の要素から。
	for i := 1; i < len(arr); i++ {
		v := arr[i]

		for ; i > 0; i-- {
			// 自分より先頭側に存在する要素に対して1つずつ、
			// その要素より1つ前の要素が大きい場合に順番を入れ替える操作を行う。
			if arr[i-1] > v {
				arr[i] = arr[i-1]
			} else {
				break
			}
		}

		// 1つ前の要素と入れ替える場合、その要素自体が配列から消えてしまっているので、
		// 入れ替える前に保存していたvを、配列に入れ直す。
		arr[i] = v
	}
	return arr
}

func main() {
	arr := []int{4, 3, 2, 1}
	fmt.Println(insertionSort(arr)) // [1 2 3 4]
}
```

12.4 ソート(2)：マージソート
12.5 ソート(3)：クイックソート
12.6 ソート(4)：ヒープソート
12.7 ソートの計算量の下界
12.8 ソート(5)：バケットソート
12.9 まとめ

13 章 グラフ(1)：グラフ探索
13.1 グラフ探索を学ぶ意義
13.2 深さ優先探索と幅優先探索
13.3 再帰関数を用いる深さ優先探索
13.4 「行きがけ順」と「帰りがけ順」
13.5 最短路アルゴリズムとしての幅優先探索
13.6 深さ優先探索と幅優先探索の計算量
13.7 グラフ探索例(1)：s-t パスを求める
13.8 グラフ探索例(2)：二部グラフ判定
13.9 グラフ探索例(3)：トポロジカルソート
13.10 グラフ探索例(4)：木上の動的計画法
13.11 まとめ

14 章 グラフ(2)：最短路問題
14.1 最短路問題とは
14.2 最短路問題の整理
14.3 緩和
14.4 DAG 上の最短路問題：動的計画法
14.5 単一始点最短路問題：ベルマン・フォード法
14.6 単一始点最短路問題：ダイクストラ法
14.7 全点対間最短路問題：フロイド・ワーシャル法
14.8 参考：ポテンシャルと差分制約系
14.9 まとめ

15 章 グラフ(3)：最小全域木問題
15.1 最小全域木問題とは
15.2 クラスカル法
15.3 クラスカル法の実装
15.4 全域木の構造
15.5 クラスカル法の正当性
15.6 まとめ

16 章 グラフ(4)：ネットワークフロー
16.1 ネットワークフローを学ぶ意義
16.2 グラフの連結度
16.3 最大流問題と最小カット問題
16.4 フォード・ファルカーソン法の実装
16.5 応用例(1)：二部マッチング
16.6 応用例(2)：点連結度
16.7 応用例(3)：プロジェクト選択問題
16.8 まとめ

17 章 P と NP
17.1 問題の難しさの測り方
17.2 P と NP
17.3 P ≠ NP 予想
17.4 NP 完全
17.5 多項式時間帰着の例
17.6 NP 困難
17.7 停止性問題
17.8 まとめ

18 章 難問対策
18.1 NP 困難問題との対峙
18.2 特殊ケースで解ける場合
18.3 貪欲法
18.4 局所探索と焼きなまし法
18.5 分枝限定法
18.6 整数計画問題への定式化
18.7 近似アルゴリズム
18.8 まとめ
