---
title: "認証・認可"
emoji: "🤖"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["認証", "認可"]
published: false
---

# 認証・認可とは

## 認証

利用者が**確かに本人である**ことを確認すること。
（Authentication。AuthN と書くことも。）

HTTPでいうと、`401 Unauthorized`。

## 認可

利用者に、**権限を与える**こと。
（Authorization。AuthZ と書くことも）

HTTPでいうと、`403 Forbidden`。

# 認証の種類

## ベーシック（Basic）認証

HTTP で定義されている認証方式の 1 つで、**簡易**な認証です。
ID とパスワードを Base64 でエンコードして、HTTP ヘッダの Authorization フィールドに記載してサーバーに送信します。

エンコード方式が分かっているので、盗聴すれば簡単に ID とパスワードが分かってしまいます。

## ダイジェスト（Digest）認証

**ベーシック認証の改良版**みたいなイメージです。
こちらも HTTP で定義されている、**簡易**な認証です。

ベージック認証では ID とパスワードを平文で送信するのに対し、
ダイジェスト認証はサーバーが生成したランダムな文字列をパスワードに付与して MD5 でハッシュ化するため、盗聴されてもパスワードの解析が困難になります。

認証の際は、サーバー側でもパスワード+ランダムな文字列でハッシュ値を算出し、それがリクエストに乗っているものと同じであれば認証します。

ただ、毎リクエストごとに Authorization フィールドに乗って ID とパスワードが送られます。

また、**ログアウトの概念がありません**。

## セッションベースの認証

リクエストのたびに ID とパスワードを送るのは、リスクが増え、認証を毎回するためオーバーヘッドも増えます。
そこでセッションベースの認証が開発されました。

1. サーバーは、ランダムな値の**セッション ID**をクライアントに送信します。セッション ID はサーバー内に保存。
2. **クライアントは、セッション ID をクッキーに保存**します。
3. （そのおかげで）サーバーはセッション ID を確認するだけで認証ができるようになります。

:::message

### クッキー（cookie）とは

サーバーからクライアントに渡されるデータ片（小さなデータ）のことです。
最初のレスポンスに乗っかってクライアントに届き、それ以降は必ずクライアント → サーバーにクッキーを戻すことになっています。

例：`display_type : large` (slim とかが選べるみたいな)
:::

:::message alert

- セッション ID が漏洩すると危険です。
- 毎回クッキーを載せた通信をするため、**CSRF** に合うリスクが高いです。
  :::


## トークンベースの認証

セッション ID のやり取りでなく、トークンを用いる手法です。

トークンで一般的に使われるのが**JWT**（**JSON Web Token**）です。
（JWT の発音は、当然正しいのはそのままアルファベット読みですが、会話でよく使われるのは`ジョット`らしいです。）
色々な情報を JSON で記述して、それを Base64 でエンコードして、秘密鍵とハッシュアルゴリズムを用いて署名を作成して、署名なしトークンと結合する...みたいな手順で作成したトークンを認証に使います。

1. ログインに成功したら、サーバーでトークンを生成してクライアントに送信。
2. クライアントは渡された**トークンをクッキーやメモリ、LocalStorage などに保存**。
3. トークンの有効期限を確認。期限切れの場合はサーバーに問い合わせて、トークンを更新してもらう。
4. クライアントは**Authorization ヘッダー**にトークンを載せてサーバーにリクエスト。
   （`Authorization: Bearer <アクセストークン>`という感じ。）
5. サーバーは、**秘密鍵**を使って署名が正しいことを確認して認証。

認証情報自体はサーバー側にありません。
なので、セッションベースの認証では DB アクセスが発生しますが、トークンベースではその必要がありません。

この「トークンベースの認証」の実装として、下記があります。
- OAuth2を使った認証
- OpenID Connectを使った認証

### OAuth2.0

「OAuth」自体は、認可のプロトコル（仕様）です。
（OAuth2.0 は、OAuth1.0 のバージョン up。）
OAuth では、**認可サーバーへのアクセストークンの要求とその応答**について取り決めされています。

「OAuth 認証」と言うと、OAuth を使った認証の実装 を表します。

:::message

#### アクセストークンとは

:::

<例>
OAuth によって、記事投稿アプリケーションに Google アカウントでサインインできるようにしたい場合は下記の流れになります。

1. 記事投稿アプリケーションから、Google の**認可サーバーに認可コードをリクエスト**。
2. ユーザーは「記事投稿アプリケーションが Google アカウントへのアクセスを許可するかどうか」を確認し、許可するか選択します。
3. 記事投稿アプリケーションは認可コードを使用して**アクセストークン**を取得し、Google の**リソースサーバーへアカウント情報をリクエスト**します。
4. 記事投稿アプリケーションは取得した Google アカウント情報を使用して、ユーザーを記事投稿アプリケーションにログインさせます。

具体的な実装としては、

- Google のプロジェクトを作成し、API 認証の設定を行う。
- 「Google へログインボタン」を記事投稿アプリケーションに設置。
- それを押すと Google のプロジェクトからユーザーに確認通知が届き、それを許可すると、登録しておいたコールバック URL（記事投稿アプリケーション内の認証処理を行う URL）にリクエストを飛ばす。
- 記事投稿アプリケーションでユーザ検索・認証を行いサインイン。

:::message

#### 認可サーバーとリソースサーバーを別々にする理由は？

認可サーバーとリソースサーバーが独立している場合、セキュリティとスケーラビリティが向上します。
認可サーバーはアクセストークンの発行と認証の管理に特化し、リソースサーバーはリソースへのアクセス権限の管理とリソースの提供に特化することができます。
このように分離することで、システムのセキュリティを強化し、リソースサーバーの機能を独立して拡張できるようになります。

ただし、小規模なアプリケーションやシステムでは、認可サーバーとリソースサーバーを同一サーバーで実装することも可能です。
この場合、セキュリティやスケーラビリティの利点は得られないかもしれませんが、シンプルな構成で簡単に実装できるという利点があります。
:::

### OpenID Connect（OIDC）

OpenID Connect は、OAuth2.0 を拡張したプロトコルです。

OAuth は認可の技術（ユーザーのリソースアクセス（WebAPI）が目的）ですので、認証も認可もしたい場合は、OpenID も OAuth も実装しないといけないということでした。
そこで、**OAuth2.0 を拡張して、認証機能を追加したのが OpenID Connect** です。

（OpenID というのは、SSO（シングルサインオン）を実現するための認証プロトコルです。）

**OAuth のアクセストークン**の発行だけでなく、識別情報を提供するための**ID トークン**の発行も行われます。

ID トークンの発行者のことを**OpenID プロバイダー**といいます。

:::message

#### SSO（シングルサインオン）とは

1 度の認証（ログイン）で、複数のシステムでの追加の認証なしで利用できるようになる仕組みのことです。
:::


:::message

### XSS と CSRF の違い

認証情報をクライアントからサーバーにどうやって送るか、Authorization ヘッダに含める場合とクッキーに含める場合で、リスクが異なります。

- Authorization ヘッダに含める方法の場合、JavaScript などからアクセス可能な場所に JWT トークンが置かれるため、XSS攻撃などでトークンがリークされる可能性があります。
- Cookie に含める方法は、Cooie に HttpOnly 属性をつけて JavaScript からのアクセスを止めることができるので、比較的安全で、推奨方法になってます。しかし、Cookie を使ったセッション管理自体が CSRF 攻撃に弱いので、その対策もちゃんとやっておく必要があります。

#### クロスサイト スクリプティング（XSS）

不正なスクリプトが実行されてしまう攻撃です。
Cookie が盗まれてしまいます。

どこにそのスクリプトが注入されるか、下記の種類があります。

- Stored XSS（永続型XSS）:
  攻撃者が悪意のあるスクリプトを**データベースなどに永続的に保存**し、それがユーザーによって表示される際に実行される攻撃です。

- Reflected XSS（反射型XSS）:
  攻撃者が悪意のあるスクリプトを**URLパラメーターやフォームのフィールドに注入**し、そのページを閲覧したユーザーにスクリプトを実行させる攻撃です。


#### クロスサイト リクエスト フォージュリ（CSRF）

（フォージュリ：偽造）

あとで

https://qiita.com/wanko5296/items/142b5b82485b0196a2da
:::

## その他

### SAML 認証
（コンシューマーでなく）エンタープライズ（法人）向けのシステムでは、ディレクトリサービスが使われることがあります。
ディレクトリサービスは、組織内のユーザーやリソースを管理するためのデータベースやサービスです。一般的なディレクトリサービスとしては、Active Directory（Microsoft）などがあります。

**SAML認証はそのディレクトリサービスで主に使われる認証**です。
ディレクトリサービスとSAML認証を組み合わせることで、企業や組織がユーザーのアクセス管理を効率的かつセキュアに行うことが可能になります。

ディレクトリサービスにはケルベロス認証も使われるのですが、クラウドサービス向きにはSAMLを使います。

SAMLに対応しているクラウドサービスが多い中、SAMLでなくOpenID Connectを使う開発も始まっています。
よく似ていることに加え、OpenID ConnectはWebブラウザ以外でも利用できるためです。

### 二要素認証 (2FA)

ユーザー名とパスワードに加えて、別の要素（通常は SMS、電話、メール、アプリによる**ワンタイムパスワード**など）を使用して認証します。

### 多要素認証 (MFA)

二要素認証と同様、複数の要素を使用して認証します。追加の要素としては指紋認証、顔認識、スマートカードなどがあります。

# 参考情報

https://arakan-pgm-ai.hatenablog.com/entry/2021/08/23/000000
https://qiita.com/Marusoccer/items/1c597dd91f4446509b61
https://techblog.roxx.co.jp/entry/2019/03/13/135739
https://developer.mamezou-tech.com/blogs/2022/12/08/jwt-auth/
https://qiita.com/TakahikoKawasaki/items/e37caf50776e00e733be
https://qiita.com/TakahikoKawasaki/items/498ca08bbfcc341691fe
https://www.youtube.com/watch?v=PKPj_MmLq5E
https://qiita.com/zizynonno/items/7eabb61cb1c3fcbc258a
https://zenn.dev/suzuki_hoge/books/2021-05-authentication-and-authorization-0259d3f
