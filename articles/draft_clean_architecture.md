---
title: "「Clean Architecture」要点"
emoji: "💠"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["設計", "クリーンアーキテクチャ"]
published: false
---

# 第 I 部　イントロダクション

【 第 1 章　設計とアーキテクチャ 】

- > 速く進む唯一の方法は、うまく進むことである。

  短期的なスピードを求めて崩壊したコードを書いても、短期的なスピードも出ないし、更にはそれが負債となって長期的に時間を奪われる。

【 第 2 章　 2 つの価値のお話 】

- 開発者には、コードやそのアーキテクチャを保護する責任がある。
  他のステークホルダーには、その重要性を評価できない（わからない）ため。

# 第 II 部　構成要素から始めよ：プログラミングパラダイム

【 第 4 章　構造化プログラミング 】

- > 構造化プログラミングは、モジュールを証明可能な単位に再帰的に分割することを可能にする。

  `証明可能`というのは、「テストによって**正しくないことを証明できる程度に小さなもの**（機能）にする必要がある」ということ。
  正しくないことを（テストによって証明しようとして）証明できなければ、その機能は十分に正しいとみなすことができる。

- **機能分割**がベストプラクティスである。

【 第 5 章　オブジェクト指向プログラミング 】

- UNIX では、すべての IO デバイスドライバに 5 つの標準機能を提供することが求められている。

  - `open` : リソースにアクセスして操作（ファイルの読み書き、デバイス操作など）を行う場合に、事前に open する必要がある。
  - `close` : close しないと、他のプロセスがそれを使用（open）できなくなってしまう。
  - `read` : 読み込み。
  - `write` : 書き込み。
  - `seek` : ファイルやデータストリーム内の位置を移動する操作。（レコードの針を落とす位置を変えるイメージ）

- オブジェクト指向プログラミングとは、アーキテクトにとっては「ポリモーフィズム（インターフェース）によって依存関係を制御できる能力」である。
  それによって、プラグインアーキテクチャ（他のものに差し替え可能になる）を作成でき、独立デプロイ可能性（独立開発可能性）が生まれる。

【 第 6 章　関数型プログラミング 】

- 関数型言語の変数は変化しない。
  これによって、競合状態や並行更新の問題が発生しなくなる。
  ただし、ストレージとプロセッサ（CPU）速度が無限にあれば完全に実現できる。

# 第 III 部　設計の原則

この部では、SOLID 原則を解説。

## 第 7 章　 SRP：単一責任の原則

- モジュールは、**1 つのアクターのみ**に対して責務を負うべき。
  （"1 つのことだけを行うべき" ではない。）

## 第 8 章　 OCP：オープン・クローズドの原則

- > ソフトウェアの構成要素（クラス、モジュール、関数）は拡張に対しては開いていて、修正に対して閉じていなければならない。

  "拡張に対して開いている"とは、他のクラスに影響を与えずに機能追加できること。
  "修正に対して閉じている"とは、修正をしたときに、そのクラスに依存している他のクラスに影響が出ないようにすること。
  （それを修正すると影響があるので容易な変更が許されない というのはダメ。）

- クラス図において、"矢印"は**使用**の関係を表す。
  `A→B` は、クラス A はクラス B を知っていて、使っている。
  "矢印の向かっている先(B)は、自身(A)を変更したときに**影響を及ぼしたくない**対象" である。

:::message
この原則は、理解を間違っているかも。これを見てみる。
https://www.youtube.com/watch?v=ET4iWuRntO4
:::

## 第 9 章　 LSP：リスコフの置換原則

- 別の型のオブジェクトに差し替えても振る舞いが変わらないようにする。
  この置換可能な型を、派生型という。

- 長方形は正方形の派生型ではない ので注意。
  長方形は幅と高さを別々に変えることができるが、正方形は両方が連動して等しくないといけないため。

## 第 10 章　 ISP：インターフェイス分離の原則

- 関係のない（使わない）ものも含むクラスに依存している場合、（関係ないもの以外の）必要なもののみを定義したインターフェースに依存させるようにする。

## 第 11 章　 DIP：依存関係逆転の原則

- 抽象だけに依存しているものが、最も柔軟なシステム。
  依存したくないのは、**変化しやすい**具象。（安定している具象なら OK。）

- インターフェースは、具象実装よりも変化しにくい。
  また、"インターフェースの変更なしで拡張できるようにする"のが設計の基本。
  つまり、*安定したインターフェースを作り、それに依存させる*こと。

- 依存関係逆転の原則の違反を完全には取り除くことはできないが、それを少数に絞り込んで分離・管理すること。

# 第 IV 部　コンポーネントの原則

## 第 13 章　コンポーネントの凝集性

### 再利用・リリース等価の原則（REP）

そのコンポーネントを再利用する単位と、リリースの単位は等しい。
1 つのコンポーネントは、まとめてリリース可能な単位でないといけない。

### 閉鎖性共通の原則（CCP）

同じ理由やタイミングで変更されるクラスは、同じコンポーネントにまとめる。変更の理由やタイミングが異なるクラスは、別のコンポーネントに分けること。
（単一責任の原則（SRP）をコンポーネントに適用したもの。）

### 全再利用の原則（CRP）

コンポーネントのユーザーが実際に使わないものへの依存を強要してはいけない。（使わないクラスは含めないこと。）
（インターフェイス分離の原則（ISP）を一般化したもの。）

### 原則の関係性

上記の 3 つのコンポーネントの凝集性に関する原則は、下記のような関係にある。
開発時の利便性と再利用性のトレードオフを考慮する必要がある。
これらのバランスをうまく取るのが腕の見せどころ。

- *REP*と*CCP*は、コンポーネントを大きくする方向に働くもの。
- *CRP*は、コンポーネントを小さくする方向に働くもの。

## 第 14 章　コンポーネントの結合

### 非循環依存関係の原則（ADP）

- コンポーネントに循環依存があってはいけない。
- もしも循環依存がある場合、依存関係逆転の原則を使う or 依存部分を切り取った新たなコンポーネントを作る。

### 安定依存の原則（SDP）

- 安定度の高い方向に依存すること。
- "安定している"とは、簡単には動かせない ということ。
  多数のコンポーネントから依存されるコンポーネントは変更しづらいため、これは安定していると言える。

### 安定度・抽象度等価の原則（SAP）

- コンポーネントの抽象度は、その安定度と同程度でなければならない。
- 安定依存の原則（SDP）で"安定度の高い方向に依存すること"と言っていて、さらにこの原則（SAP）を踏まえると、
  抽象度の高いものに依存すべき（依存関係逆転の原則（DIP））ということになる。

# 第 V 部　アーキテクチャ

【 第 15 章　アーキテクチャとは？ 】

- アーキテクトは、プログラマを続けておかなければならない。
- 優れたアーキテクトは、方針と詳細を区別して依存することがないように切り離し、詳細（どんな方法・ツールを使うか）の決定を遅らせ、後からでも柔軟に対応できるよう選択肢を残す。

【 第 19 章　方針とレベル 】

- "入力/出力"から距離が遠いほど、上位レベルの（依存すべき）コンポーネント。

【 第 21 章　叫ぶアーキテクチャ 】

- アプリケーションの**アーキテクチャは**、フレームワークに関するものであるべきでなく、**ユースケースに基づいているべき**。
  （図書館の設計図が、図書館としてのユースケースを表現している（叫んでいる）ように。）
- ツールに何を使うかでなく、**ユースケースを満たしているか**が重要。

## 第 22 章　クリーンアーキテクチャ

クリーンアーキテクチャでは以下の特性を実現する。

- フレームワーク非依存
  システムをフレームワークの制約で縛るのでなく、フレームワークをツールとして利用する。
- テスト可能
  ビジネスルールは、UI、データベース、Web サーバー、その他の外部要素がなくてもテストできる。
- UI 非依存
  ビジネスルールを変更することなく、UI を（例えばコンソール UI→ ウェブ UI に）置き換えることができる。
- データベース非依存
  DB を置き換えることができる。
- 外部エージェント非依存
  ビジネスルールは、外界のインターフェースについては何も知らない。

### 依存性のルール

![](https://storage.googleapis.com/zenn-user-upload/da7e0fe18b54-20240424.jpg)
_・普通の矢印 : 依存を表す。_
_・白抜きの矢印 : 汎化（抽象化すること。要はインターフェースを作ること）。逆方向へは、実装。_
_・ユースケースインタラクター : ユースケースを実装したクラスのこと。要は、ユースケースのこと。_

- ソースコードの**依存性は、内側（上位レベルの方針）だけに向かっていなければならない**。
  アーキテクチャの**境界を横切る依存性（矢印）の向きは、抽象に向かっている**。
- **境界線を超えてデータを渡すとき**、
  方向が外 → 内の場合は、常に**内側の円にとって便利な形式**にする。
  （外側にとって扱いやすい形式で渡してしまうと、内側が外側のことを知ってしまうため。）
  内 → 外の場合は、プレーンな（単純な）データ構造にする。

#### エンティティ（一番内側の黄色の円）

いわゆる、ドメインオブジェクト。

- 最重要ビジネスデータと最重要ビジネスルールをまとめて、カプセル化したもの。
- まとめ方は、クラスでも、モジュールとしてでもいい。
- 最重要ビジネスデータ（ルール）かどうか は、"ビジネスによって欠かせないものであり、システムとして**自動化されていなくても存在するもの**かどうか"。
  - ビジネスルールとは、お金を生み出したり節約したりするルールや手続き。

#### ユースケース（内側から 2 番目の赤色の円）

- システムを使う方法（ユーザの入力、ユーザに返す出力、処理ステップなど）を記述したもの。
- ビジネスルールの中でも、エンティティほど純粋でないもの。
  **アプリケーション固有**のビジネスルール を記載している。
- ユーザーインターフェースは記述しない。
- ユースケースは、エンティティを制御する。

#### インターフェースアダプター（内側から 3 番目の緑色の円）

内側の円（レイヤー）にとって便利なデータフォーマットから、外側の円に便利なように変換する役目。

- コントローラー
- プレゼンター
- ゲートウェイ

#### フレームワークとドライバ（一番外側の青色の円）

ここには**詳細**を置く。

- UI（GUI、CUI など）
- Web（Web、パッケージソフト、組込など）
- デバイス（PC、スマホなど）
- DB（RDMS、NoSQL など）
- 外部インターフェース（外部サービス、マイクロサービス間連携など）

## 第 23 章　プレゼンターと Humble Object

- テストしやすい振る舞い と テストしにくい振る舞い を、2 つのモジュールやクラスに分割する。
  この Humble Object パターンが、プレゼンターで使われている。
  View は（GUI パーツだったりするので）テストしにくい。
  Presenter は View 用にデータを変換する役割なので、その点についてテストしやすい。
- データベースゲートウェイは、DB 操作（Insert, Select など）のメソッドのインターフェース。
  スタブに置き換えできるようにしているので、ユースケースはテストしやすい。
- ORM は、DB レイヤー。

【 第 24 章　部分的な境界 】

- 本格的に境界を作るのはコストが高い。
  コストを抑える方法として、下記 2 つが考えられる。これらは例で、他にも方法はある。
  - 両側でなく、片側だけに境界（インターフェース）を作る。
  - 更にシンプルにするには、Facade パターンを使う。

## 第 25 章　レイヤーと境界

- 境界を完全に構築しようとすると、コストが高くつく。
  - 現時点で見えている境界
  - 見ようとすれば見える境界（作ろうとすればなんぼでも作れる境界）
  - 今後要望がでてきて必要になりそうだなと予測する境界
- 境界がどこにあるのか見定め、コストを評価し、完全に実装する必要があるのか、部分的でいいのか、無視するのか、判断が必要。
- また、一度判断した後も、システムの進化に合わせて常に見張る必要がある。

【 第 26 章　メインコンポーネント 】

- `main`は究極的な詳細。
  初期状態や構成を設定して、外部リソースを集める。

【 第 28 章　テスト境界 】

- テストはシステムの一部。テストはシステムのコンポーネントに依存しているため、一番外側の円にある。
- テストも**変化しやすいものに依存しない**こと。すぐ壊れ、メンテが頻繁に必要になってしまう。

第 VI 部　詳細

第 30 章　データベースは詳細
リレーショナルデータベース
なぜデータベースシステムが普及しているのか？
もしもディスクがなかったら？
詳細
だけど、パフォーマンスはどうなの？
小話
まとめ

第 31 章　ウェブは詳細
止まらない振り子
結論
まとめ

第 32 章　フレームワークは詳細
フレームワークの作者たち
一方的な結婚
リスク
解決策
今あなたたちを夫婦として宣言する
まとめ

第 33 章　事例：動画販売サイト
プロダクト
ユースケース分析
コンポーネントアーキテクチャ
依存性管理
まとめ

第 34 章　書き残したこと

第 VII 部　付録

付録 A 　アーキテクチャ考古学

### temp

- アーキテクチャの境界 : 抽象と具象の区切り。図 11-1 の曲線。

- DS: DataStructure（データ構造）

- データモデルとドメインモデルは違う。重要らしい。
