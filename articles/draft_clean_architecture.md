---
title: "「Clean Architecture」要点"
emoji: "💠"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["設計", "クリーンアーキテクチャ"]
published: false
---

# 第 I 部　イントロダクション

## 第 1 章　設計とアーキテクチャ

- > 速く進む唯一の方法は、うまく進むことである。

  短期的なスピードを求めて崩壊したコードを書いても、短期的なスピードも出ないし、更にはそれが負債となって長期的に時間を奪われる。

## 第 2 章　 2 つの価値のお話

- 開発者には、コードやそのアーキテクチャを保護する責任がある。
  他のステークホルダーには、その重要性を評価できないため。

# 第 II 部　構成要素から始めよ：プログラミングパラダイム

## 第 3 章　パラダイムの概要

過去に、3 つのパラダイムがあった。
構造化プログラミング、オブジェクト指向プログラミング、関数型プログラミング

## 第 4 章　構造化プログラミング

- > 構造化プログラミングは、モジュールを証明可能な単位に再帰的に分割することを可能にする。

  `証明可能`というのは、「テストによって**正しくないことを証明できる程度に小さなもの**（機能）にする必要がある」ということ。
  正しくないことを（テストによって証明しようとして）証明できなければ、その機能は十分に正しいとみなすことができる。

- **機能分割**がベストプラクティスである。

## 第 5 章　オブジェクト指向プログラミング

- UNIX では、すべての IO デバイスドライバに 5 つの標準機能を提供することが求められている。

  - `open` : リソースにアクセスして操作（ファイルの読み書き、デバイス操作など）を行う場合に、事前に open する必要がある。
  - `close` : close しないと、他のプロセスがそれを使用（open）できなくなってしまう。
  - `read` : 読み込み。
  - `write` : 書き込み。
  - `seek` : ファイルやデータストリーム内の位置を移動する操作。（レコードの針を落とす位置を変えるイメージ）

- オブジェクト指向プログラミングとは、アーキテクトにとっては「ポリモーフィズム（インターフェース）によって依存関係を制御できる能力」である。
  それによって、プラグインアーキテクチャ（他のものに差し替え可能になる）を作成でき、独立デプロイ可能性（独立開発可能性）が生まれる。

## 第 6 章　関数型プログラミング

- 関数型言語の変数は変化しない。
  これによって、競合状態や並行更新の問題が発生しなくなる。
  ただし、ストレージとプロセッサ（CPU）速度が無限にあれば完全に実現できる。

# 第 III 部　設計の原則

第 7 章　 SRP：単一責任の原則
症例 1：想定外の重複
症例 2：マージ
解決策
まとめ

第 8 章　 OCP：オープン・クローズドの原則
思考実験
方向の制御
情報隠蔽
まとめ

第 9 章　 LSP：リスコフの置換原則
継承の使い方の指針
正方形・長方形問題
リスコフの置換原則（LSP）とアーキテクチャ
リスコフの置換原則（LSP）違反の例
まとめ

第 10 章　 ISP：インターフェイス分離の原則
インターフェイス分離の原則（ISP）と言語との関係
インターフェイス分離の原則（ISP）とアーキテクチャとの関係
まとめ

第 11 章　 DIP：依存関係逆転の原則
安定した抽象
Factory
具象コンポーネント
まとめ

第 IV 部　コンポーネントの原則

第 12 章　コンポーネント
コンポーネントの簡単な歴史
リロケータビリティ（再配置可能性）
リンカ
まとめ

第 13 章　コンポーネントの凝集性
再利用・リリース等価の原則（REP）
閉鎖性共通の原則（CCP）
全再利用の原則（CRP）
コンポーネントの凝集性のテンション図
まとめ

第 14 章　コンポーネントの結合
非循環依存関係の原則（ADP）
トップダウンの設計
安定依存の原則（SDP）
安定度・抽象度等価の原則（SAP）
まとめ

第 V 部　アーキテクチャ

第 15 章　アーキテクチャとは？
開発
デプロイ
運用
保守
選択肢を残しておく
デバイス非依存
ダイレクトメール
物理アドレス
まとめ

第 16 章　独立性
ユースケース
運用
開発
デプロイ
選択肢を残しておく
レイヤーの切り離し
ユースケースの切り離し
切り離し方式
独立した開発が可能
独立デプロイ可能性
重複
切り離し方式（再び）
まとめ

第 17 章　バウンダリー：境界線を引く
結合の悲しい物語
FitNesse
あなたの境界線は何か？　いつ境界線を引くのか？
入力と出力はどうする？
プラグインアーキテクチャ
プラグインの戦い
まとめ

第 18 章　境界の解剖学
境界を越える
恐怖のモノリス
デプロイコンポーネント
スレッド
ローカルプロセス
サービス
まとめ

第 19 章　方針とレベル
レベル
まとめ

第 20 章　ビジネスルール
エンティティ
ユースケース
リクエストとレスポンスのモデル
まとめ

第 21 章　叫ぶアーキテクチャ
アーキテクチャのテーマ
アーキテクチャの目的
だが、ウェブはどうか？
フレームワークはツールであり、生き方ではない
テスト可能なアーキテクチャ
まとめ

第 22 章　クリーンアーキテクチャ
依存性のルール
典型的なシナリオ
まとめ

第 23 章　プレゼンターと Humble Object
Humble Object パターン
プレゼンターとビュー
テストとアーキテクチャ
データベースゲートウェイ
データマッパー
サービスリスナー
まとめ

第 24 章　部分的な境界
最後のステップを省略する
片方だけの境界
Facade
まとめ

第 25 章　レイヤーと境界
Hunt the Wumpus
クリーンアーキテクチャ？
流れを横切る
流れを分割する
まとめ

第 26 章　メインコンポーネント
究極的な詳細
まとめ

第 27 章　サービス：あらゆる存在
サービスアーキテクチャ？
サービスのメリット？
子猫の問題
救世主のオブジェクト
コンポーネントベースのサービス
横断的関心事
まとめ

第 28 章　テスト境界
システムコンポーネントとしてのテスト
テスト容易性のための設計
テスト API
まとめ

第 29 章　クリーン組込みアーキテクチャ
適性テスト
ターゲットハードウェアのボトルネック
まとめ

第 VI 部　詳細

第 30 章　データベースは詳細
リレーショナルデータベース
なぜデータベースシステムが普及しているのか？
もしもディスクがなかったら？
詳細
だけど、パフォーマンスはどうなの？
小話
まとめ

第 31 章　ウェブは詳細
止まらない振り子
結論
まとめ

第 32 章　フレームワークは詳細
フレームワークの作者たち
一方的な結婚
リスク
解決策
今あなたたちを夫婦として宣言する
まとめ

第 33 章　事例：動画販売サイト
プロダクト
ユースケース分析
コンポーネントアーキテクチャ
依存性管理
まとめ

第 34 章　書き残したこと

第 VII 部　付録

付録 A 　アーキテクチャ考古学
