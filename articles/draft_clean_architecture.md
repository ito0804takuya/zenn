---
title: "「Clean Architecture」要点"
emoji: "💠"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["設計", "クリーンアーキテクチャ"]
published: false
---

# 第 I 部　イントロダクション

## 第 1 章　設計とアーキテクチャ

- > 速く進む唯一の方法は、うまく進むことである。

  短期的なスピードを求めて崩壊したコードを書いても、短期的なスピードも出ないし、更にはそれが負債となって長期的に時間を奪われる。

## 第 2 章　 2 つの価値のお話

- 開発者には、コードやそのアーキテクチャを保護する責任がある。
  他のステークホルダーには、その重要性を評価できないため。

# 第 II 部　構成要素から始めよ：プログラミングパラダイム

## 第 3 章　パラダイムの概要

過去に、3 つのパラダイムがあった。
構造化プログラミング、オブジェクト指向プログラミング、関数型プログラミングである。

## 第 4 章　構造化プログラミング

- > 構造化プログラミングは、モジュールを証明可能な単位に再帰的に分割することを可能にする。

  `証明可能`というのは、「テストによって**正しくないことを証明できる程度に小さなもの**（機能）にする必要がある」ということ。
  正しくないことを（テストによって証明しようとして）証明できなければ、その機能は十分に正しいとみなすことができる。

- **機能分割**がベストプラクティスである。

## 第 5 章　オブジェクト指向プログラミング

- UNIX では、すべての IO デバイスドライバに 5 つの標準機能を提供することが求められている。

  - `open` : リソースにアクセスして操作（ファイルの読み書き、デバイス操作など）を行う場合に、事前に open する必要がある。
  - `close` : close しないと、他のプロセスがそれを使用（open）できなくなってしまう。
  - `read` : 読み込み。
  - `write` : 書き込み。
  - `seek` : ファイルやデータストリーム内の位置を移動する操作。（レコードの針を落とす位置を変えるイメージ）

- オブジェクト指向プログラミングとは、アーキテクトにとっては「ポリモーフィズム（インターフェース）によって依存関係を制御できる能力」である。
  それによって、プラグインアーキテクチャ（他のものに差し替え可能になる）を作成でき、独立デプロイ可能性（独立開発可能性）が生まれる。

## 第 6 章　関数型プログラミング

- 関数型言語の変数は変化しない。
  これによって、競合状態や並行更新の問題が発生しなくなる。
  ただし、ストレージとプロセッサ（CPU）速度が無限にあれば完全に実現できる。

# 第 III 部　設計の原則

この部では、SOLID 原則を解説。

## 第 7 章　 SRP：単一責任の原則

- モジュールは、**1 つのアクターのみ**に対して責務を負うべき。
  （"1 つのことだけを行うべき" ではない。）

## 第 8 章　 OCP：オープン・クローズドの原則

- > ソフトウェアの構成要素（クラス、モジュール、関数）は拡張に対しては開いていて、修正に対して閉じていなければならない。

  "拡張に対して開いている"とは、他のクラスに影響を与えずに機能追加できること。
  "修正に対して閉じている"とは、修正をしたときに、そのクラスに依存している他のクラスに影響が出ないようにすること。
  （それを修正すると影響があるので容易な変更が許されない というのはダメ。）

- クラス図において、"矢印"は**使用**の関係を表す。
  `A→B` は、クラス A はクラス B を知っていて、使っている。
  "矢印の向かっている先(B)は、自身(A)を変更したときに**影響を及ぼしたくない**対象" である。

:::message
この原則の理解は、間違っているかも。これを見てみる。
https://www.youtube.com/watch?v=ET4iWuRntO4
:::

## 第 9 章　 LSP：リスコフの置換原則

- 別の型のオブジェクトに差し替えても振る舞いが変わらないようにする。
  この置換可能な型を、派生型という。

- 長方形は正方形の派生型ではない ので注意。
  長方形は幅と高さを別々に変えることができるが、正方形は両方が連動して等しくないといけないため。

## 第 10 章　 ISP：インターフェイス分離の原則

- 関係のないものも含むクラスに依存している場合、（関係ないもの以外の）必要なもののみを定義したインターフェースに依存させるようにする。

## 第 11 章　 DIP：依存関係逆転の原則

- 抽象だけに依存しているものが、最も柔軟なシステム。
  依存したくないのは、**変化しやすい**具象。（安定している具象なら OK。）

- インターフェースは、具象実装よりも変化しにくい。
  また、"インターフェースの変更なしで拡張できるようにする"のが設計の基本。
  つまり、*安定したインターフェースを作り、それに依存させる*こと。

- 依存関係逆転の原則の違反を完全には取り除くことはできないが、それを少数に絞り込んで分離・管理すること。

### temp

- アーキテクチャの境界 : 抽象と具象の区切り。図 11-1 の曲線。
- 依存性のルール : アーキテクチャの境界を横切る依存性（矢印）の向きは、抽象に向かっている。

# 第 IV 部　コンポーネントの原則

SOLID 原則は、レンガで部屋を作る方法。
コンポーネントの原則は、部屋を組み合わせて建物を作る方法 についての原則。

## 第 12 章　コンポーネント

よくわからなかった。

## 第 13 章　コンポーネントの凝集性

### 再利用・リリース等価の原則（REP）

そのコンポーネントを再利用する単位と、リリースの単位は等しい。
1 つのコンポーネントは、まとめてリリース可能な単位でないといけない。

### 閉鎖性共通の原則（CCP）

同じ理由やタイミングで変更されるクラスは、同じコンポーネントにまとめる。変更の理由やタイミングが異なるクラスは、別のコンポーネントに分けること。
（単一責任の原則（SRP）をコンポーネントに適用したもの。）

### 全再利用の原則（CRP）

コンポーネントのユーザーが実際に使わないものへの依存を強要してはいけない。（使わないクラスは含めないこと。）
（インターフェイス分離の原則（ISP）を一般化したもの。）

### 原則の関係性

上記の 3 つのコンポーネントの凝集性に関する原則は、下記のような関係にある。
開発時の利便性と再利用性のトレードオフを考慮する必要がある。
これらのバランスをうまく取るのが腕の見せどころ。

- *REP*と*CCP*は、コンポーネントを大きくする方向に働くもの。
- *CRP*は、コンポーネントを小さくする方向に働くもの。

## 第 14 章　コンポーネントの結合

### 非循環依存関係の原則（ADP）

- コンポーネントに循環依存があってはいけない。
- もしも循環依存がある場合、依存関係逆転の原則を使う or 依存部分を切り取った新たなコンポーネントを作る。

### 安定依存の原則（SDP）

- 安定度の高い方向に依存すること。
- "安定している"とは、簡単には動かせない ということ。
  多数のコンポーネントから依存されるコンポーネントは変更しづらいため、これは安定していると言える。

### 安定度・抽象度等価の原則（SAP）

- コンポーネントの抽象度は、その安定度と同程度でなければならない。
- 安定依存の原則（SDP）で"安定度の高い方向に依存すること"と言っていて、さらにこの原則（SAP）を踏まえると、
  抽象度の高いものに依存すべき（依存関係逆転の原則（DIP））ということになる。

第 V 部　アーキテクチャ

第 15 章　アーキテクチャとは？
開発
デプロイ
運用
保守
選択肢を残しておく
デバイス非依存
ダイレクトメール
物理アドレス
まとめ

第 16 章　独立性
ユースケース
運用
開発
デプロイ
選択肢を残しておく
レイヤーの切り離し
ユースケースの切り離し
切り離し方式
独立した開発が可能
独立デプロイ可能性
重複
切り離し方式（再び）
まとめ

第 17 章　バウンダリー：境界線を引く
結合の悲しい物語
FitNesse
あなたの境界線は何か？　いつ境界線を引くのか？
入力と出力はどうする？
プラグインアーキテクチャ
プラグインの戦い
まとめ

第 18 章　境界の解剖学
境界を越える
恐怖のモノリス
デプロイコンポーネント
スレッド
ローカルプロセス
サービス
まとめ

第 19 章　方針とレベル
レベル
まとめ

第 20 章　ビジネスルール
エンティティ
ユースケース
リクエストとレスポンスのモデル
まとめ

第 21 章　叫ぶアーキテクチャ
アーキテクチャのテーマ
アーキテクチャの目的
だが、ウェブはどうか？
フレームワークはツールであり、生き方ではない
テスト可能なアーキテクチャ
まとめ

第 22 章　クリーンアーキテクチャ
依存性のルール
典型的なシナリオ
まとめ

第 23 章　プレゼンターと Humble Object
Humble Object パターン
プレゼンターとビュー
テストとアーキテクチャ
データベースゲートウェイ
データマッパー
サービスリスナー
まとめ

第 24 章　部分的な境界
最後のステップを省略する
片方だけの境界
Facade
まとめ

第 25 章　レイヤーと境界
Hunt the Wumpus
クリーンアーキテクチャ？
流れを横切る
流れを分割する
まとめ

第 26 章　メインコンポーネント
究極的な詳細
まとめ

第 27 章　サービス：あらゆる存在
サービスアーキテクチャ？
サービスのメリット？
子猫の問題
救世主のオブジェクト
コンポーネントベースのサービス
横断的関心事
まとめ

第 28 章　テスト境界
システムコンポーネントとしてのテスト
テスト容易性のための設計
テスト API
まとめ

第 29 章　クリーン組込みアーキテクチャ
適性テスト
ターゲットハードウェアのボトルネック
まとめ

第 VI 部　詳細

第 30 章　データベースは詳細
リレーショナルデータベース
なぜデータベースシステムが普及しているのか？
もしもディスクがなかったら？
詳細
だけど、パフォーマンスはどうなの？
小話
まとめ

第 31 章　ウェブは詳細
止まらない振り子
結論
まとめ

第 32 章　フレームワークは詳細
フレームワークの作者たち
一方的な結婚
リスク
解決策
今あなたたちを夫婦として宣言する
まとめ

第 33 章　事例：動画販売サイト
プロダクト
ユースケース分析
コンポーネントアーキテクチャ
依存性管理
まとめ

第 34 章　書き残したこと

第 VII 部　付録

付録 A 　アーキテクチャ考古学
