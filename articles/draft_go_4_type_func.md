---
title: "Go 型・関数"
emoji: "😸"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Go"]
published: false
---

# 型

## <組み込み型>

- 整数 :
  int
  byte（int8 のエイリアス）
  rune（int32 のエイリアス）
  int64
  uint（負数以外（0 以上）を扱う） など
- 浮動小数点数 : float32, float64
- 文字列 : string
  :::message
  ダブルクォーテーション (") で囲む。
  シングルクォーテーション (')で囲むのは、rune。
  :::
  :::message
  エスケープはバックスラッシュ (`\`)。
  リテラルはバッククォート (`)。
  :::
- 真偽値 : bool
  :::message alert
  他の言語のように**暗黙的に 0, 1 に変換しない**。**明示的に行う必要あり**。
  :::

## <型変換(キャスト)>

基本は、**strconv**パッケージを使う。

ただし、数値同士のキャストは`T(v)`でできる。

```go:T(v)
var f float64 = 10
var n int = int(f)
```

### よく使うもの

- `Atoi` : 文字列 → int（32 か 64 なのかは環境依存）
- `Itoa` : int → 文字列
  :::message
  A は ASCII コード を表す。
  :::

```go:Atoi, Itoa
i, _ := strconv.Atoi("-42") // Atoi は返り値が2つあり、2つ目は使わないため、 _ で、これから使わないことを明示。
s := strconv.Itoa(-42)
```

### あまり使わないもの

- ParseX : 文字列 → X
  - ParseInt : 文字列 → int（指定の bit 値への変換）
  - ParseFloat : 文字列 → float
  - ParseUint : 文字列 → uint
  - ParseBool : 文字列 → bool
- FormatX : X → 文字列
  - FormatInt : int8 など（int が指す bit 値ではない bit 値） → 文字列
  - FormatUint : uint → 文字列
  - FormatFloat : float → 文字列
  - FormatBool : bool → 文字列

## <型の確認>

型の確認は、`reflect.TypeOf()` でできる。

```go
fmt.Println( reflect.TypeOf(v) )
```

## <コンポジット型>

複合データ型。構造体、配列、スライス、マップ がある。

### 構造体

**型の異なる**データを集めたデータ型。

- 初期化方法 : `struct { name string, age int }`
- 操作 : 参照も代入も、`.`でアクセスできる。
  ```go
  var person struct {
    name string
    age  int
  }
  // .でアクセス
  person.name = "太郎"
  fmt.Println(person.name) // 太郎
  ```

### 配列

**同じ型**のデータを集めたデータ型。
**要素数は変更できない**。

- 初期化方法
  - `[2]string{"hoge", "fuga"}`
  - `[...]string{"hoge", "fuga"}`
  - `[...]int{2: 10, 5: 20}`
    `arr[i]`にあたる位置に値を指定する方法。この例だと`[0 0 10 0 0 20]`となる。
- 操作
  - アクセス : `arr[3]`
  - 長さ : `len(arr)`
  - スライス演算 : `arr[2:5]`
    配列からスライスを作る。この例だと`arr[2] から arr[5-1] まで`を抽出したものになる。
    ```go:スライス演算
    arr := [...]string{"a", "b", "c", "d", "e", "f"}
    fmt.Println(arr[2:5]) // [c d e]
    ```

### スライス

**配列の一部を切り出した**データ型。
（スライスは配列を切り出したものなので、**背後には必ず配列が存在する**。）

:::message
スライスを使うときは、参照している（後ろの）配列を意識すること。
:::

配列との大きな違いは、スライスの**長さ**（サイズ）が固定ではなく**動的**であること。

スライスは下記 3 つの要素を持っている。（この 3 要素の構造体である。）

1. **ポインタ** : 基となる配列の最初の要素の場所（切り出した場所）を表す。
2. **len** : 切り出した長さ。
3. **cap** : 基になる配列に対して、ポインタの位置（切り出した位置）から配列の終端までの要素数。つまり、このスライスはどこまで拡張できるのかを表す量。

- 初期化方法
  - `arr[2:5]`
    **スライス演算子**`s[i:p]`によって、（既にある）配列から切り出す方法。
    この例だと`arr[2] から arr[5-1] まで`を抽出したものになる。
    i と p は省略することもでき、配列の全要素をベースにする場合は`arr[:]`となる。
  - `[]int{1, 2, 3}`
    **スライスリテラル**で、基になる配列は指定せずにスライスだけを作る方法。
    （正しくは、内部的に`{1, 2, 3}`の配列が自動で作られ、それをスライスが参照している。）
  - `[]int{2: 10, 5: 20}`
    `slice[i]`にあたる位置に値を指定する方法。この例だと`[0 0 10 0 0 20]`となる。
  - `make([]int, 3, 10)`
    **make メソッド**によって**指定した要素数、容量のスライスを作る**方法。`make([]型名, length, capacity)`
- 操作
  - アクセス : `sl[3]`
  - 長さ : `len(sl)`
  - 容量 : `cap(sl)`
  - 要素の**追加** : `sl = append(sl, 50, 60)`
  - 要素の**削除**
    下記のどちらも、（削除したい要素を除外した）削除しない側の 2 つの要素郡をくっつけることで、要素を削除したスライスを作成している。
    - i 番目の要素のみ削除 : `a = append(a[:i], a[i+1]...)`
    - i~j 番目の要素を削除 : `a = append(a[:i], a[j]...)`

:::message

### append メソッドについて

```go:構文
<スライス> = append(<スライス>, <以降、追加したい要素>)
```

- 第一引数は追加するスライスで、第二引数以降は追加したい要素。
- 左辺はもちろん決まってはいないが、**そのスライス（変更を加えたスライス変数）で受ける**のがバグが起こらなく**安全**なので、（別のスライスで受けたりせずに）こういう構文だと覚えるのがいい。

#### [append の挙動]

- cap が足りる場合は、新しい要素を基となる配列の後ろにコピーして、len を更新すれば、要素を追加できる。
- cap が足りない場合は、後ろに追加したくてもできないので、**元の約 2 倍の容量の配列**（を置けるメモリ）**を確保し直す**。その新しい配列を参照するようにポインタを貼り直して、元の配列から要素をコピーする。そして、新しい要素をその配列にコピーして、len と cap を更新する。
  → なので、append メソッドの左辺を別のスライスで受けると、別の配列を参照してしまっているということになりかねない。

:::details コードでの解説

```go
// --------------------- スライスa ---------------------
a := []int{10, 20}
fmt.Println("A-1:", a, cap(a))

// --------------------- スライスb ---------------------
// aのスライスに30を追加したものを、別のbというスライスで受けると、どうなるのか？
b := append(a, 30)
fmt.Println("B-1:", b, cap(b)) // B-1: [10 20 30] 4
fmt.Println("A-2:", a, cap(a)) // A-2: [10 20] 2
// → aには追加されておらず、bにしか追加されていない。
// つまり、スライスaとbは、別の配列をベースとして参照している。
// これは、新しい要素30を追加するには、aのcapのままでは足りなかったため、配列を配置する容量を再確保したため。
// bはaとは別の空間（配列）を参照するようになってしまった。

// aに変更を加えた。bにもこの変更は伝わるのか？
a[0] = 100
fmt.Println("A-3:", a, cap(a)) // A-3: [100 20] 2
fmt.Println("B-2:", b, cap(b)) // B-2: [10 20 30] 4
// → bにaの変更が伝搬しなかった。スライスaとbは、別の配列を参照しているため、当然。

// --------------------- スライスc ---------------------
// aのスライスに30を追加したものを、別のbというスライスで受けた。
// が、bには1つ容量が空いている（cap(b)が4で、実際には10, 20, 30の3つしか使っていない）ので、
// 配列は再確保されず、bとcは同じ配列を参照する。
c := append(b, 40)
fmt.Println("C-1:", c, cap(c)) // C-1: [10 20 30 40] 4

// bに変更を加えたが、bとcは同じ配列を参照しているので、当然cにもこの変更は伝わる。
b[1] = 200
fmt.Println("B-3:", b, cap(b)) // B-3: [10 200 30] 4
fmt.Println("C-2:", c, cap(c)) // C-2: [10 200 30 40] 4
```

:::

:::message alert
append の挙動によって、**配列が再確保される場合がある**ので、**append は必ず元のスライスで受けること**。
:::

### マップ

**キーと値**をマッピングしたデータ型。

- 初期化方法
  - `map[string]int{ "hoge": 1, "fuga": 2 }`
  - `make(map[string]int)`
- 操作
  - アクセス : `m["x"]`
  - 存在確認 : `n, ok := m["z"]` で、n には値、ok には bool が入る。
  - 追加 : `m["z"] = 30`
  - 削除 : `delete(m, "z")`

:::message

## <ゼロ値>

| 型       | ゼロ値                 |
| -------- | ---------------------- |
| int      | 0                      |
| string   | ""                     |
| bool     | false                  |
| 構造体   | フィールドの型のゼロ値 |
| 配列     | 要素の型のゼロ値       |
| スライス | _nil_                  |
| マップ   | _nil_                  |

:::

## <ユーザ定義型>

`type 型名 基底型` で定義する。（基底型 : 基にする型。）

なので、ユーザ定義型というのは struct だけでなく、`type MyInt int`とかも定義できる。

---

# 関数
