---
title: "[WIP] リーダブルコード メモ"
emoji: "📑"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["可読性"]
published: false
---

# 概要

リーダブルコードを読んで、個人的に重要と感じた点を、備忘録としてメモする。
https://www.oreilly.co.jp/books/9784873115658/

## 1 章 コードは理解しやすくあるべき

- **読む人がそれを理解するのに必要な時間が最も短くなるように**、コードを書くこと。

# パート 1

[表層レベルの改善]で可読性を上げていく。
リファクタリングやコードの変更を行うことなく、小さな労力で実施できる。

## 2 章 名前に情報を詰める

- **具体的な単語**を選ぶこと。
  汎用的すぎたり、伝える内容が薄い単語は避ける。
- **カラフルな単語**を選ぶこと。
- tmp という単語は本当に一時的かつ局所的なら OK。
- ループのイテレーターとして`i`や`j`を使うのは OK。
  場合によっては、複数の配列をネストループするときなどは、users 配列のイテレーターの`ui `、members 配列のイテレーターの`mi`などと命名したほうが良い。
- 変数名に単位をつけたほうが伝わりやすい。（`s`なのか`ms`なのか、`MB`なのか`GB`なのか）
- スコープが小さいなら、変数名も短いものでOK。その変数がどういうものか定義した行が、それを使う行のすぐ近くにあるため。2,3行上のコードを見ればすぐわかる。
  逆に言うと、スコープが大きいと、それが何かを理解するのに必要な情報を詰め込んだ名前 にしないといけない。

# パート 2

複雑なロジックであっても、心理的負担をかけず脳内メモリを専有せずに、読み手が簡単に理解できるようにすることがゴール。

## 7 章 制御フローを読みやすくする

- 比較演算子の左側には比較したいもの（変化するもの）、右側には比較の基準となるもの（より一定であるもの=定数や定数に近いもの）を置く。

```ruby
if recieved_value > expected_value
```

- 条件分岐では、否定形でなく肯定形を使い、関心が高い or 目立つ条件を先に書く。
- コードの行数を減らすのでなく、**コードを読む時間**が減るように書く。
  （感想: コードの行数を減らすことも大事。ただ、そのせいで読みにくくなってはいけない。）
- 三項演算子を使うのは、簡単な条件分岐の場合のみ。
- 早期リターンすること。

## 8 章 巨大な表現を噛み砕く

- 説明変数を使う。
- ド・モルガンの法則を使う

```
!(A || B) は (!A && !B) に等しい ... 'AかB でない' = 'Aでない かつ bでない'
!(A && B) は (!A || !B) に等しい ... 'AかつB でない' = 'Aでない か Bでない'
```

https://basics.k-labo.work/2017/08/31/%E8%AB%96%E7%90%86%E6%BC%94%E7%AE%97/

- DRY(Don’t Repeat Yourself)

## 9 章 変数と可読性

- JavaScript では変数にはいつも`const`を付けること。(付けないとグローバル変数になる。)
- 変数のスコープは狭く。
  - JavaScript と Python は、ループ内で定義した変数もループ外で使えるため、注意が必要。（スコープが広い）

# パート 3

- 1 度に 1 つのことしかしないコードにする。
- まず、**やりたいことを言葉で説明する文章を作る**。（擬似コード）
  そうやって、これからやるべきことをきちんと理解してから、コードを書く。
  ラバーダッキングは更に効果的。

## 10 章 無関係な問題を抽出する

- 関数内で、やりたいことと関係のないことを行っているコードは、別の関数に分ける。
- 細かすぎる単位で関数に分けると、かえって読みにくくなる。コードをジャンプして読まないといけなくなるため。
- プロジェクト（ドメイン）特有のコードは、一般的なコードから隔離する。

## 11 章 1 度に 1 つのタスク

- 1 度に 1 つのタスクを行うこと。

## 12 章 考えをコードに変換する

- 否定（not）をできるだけ使わない。複雑なロジックの中で否定を使うと理解が難しくなる。
- ライブラリが提供しているものを知ることで、コードを簡潔に書ける。

## 13 章 コードを書かない

- **コードを書くと、それをテストしたりメンテナンスする必要が生じる**。
  ライブラリを使ったり機能を排除したりすることで、**コードを書かずに済み**、時間を節約できる。
- すべての機能を実装したがる傾向がプログラマーにはある。ほとんどの機能は、未完成に終わる or 使われない or アプリケーションを複雑にするだけ。（オーバーエンジニアリング）
  また、機能の実装にかかる労力を過小評価する傾向がプログラマーにはある。実装自体の時間に加え、将来のメンテナンス、ドキュメンテーション、アプリケーションに追加されたコードの「重量」（どれだけ複雑にしたか）を考えていない。
- 要求に対し、本当に必要かどうか、疑問を持つ。
  要求を分解する。
- プロジェクト内のコードを小さくする。
  - 重複したコードをまとめる。
  - 使われていないコードを削除する。
- 標準ライブラリや、使用しているライブラリの機能を把握する。
  - たまに 15 分間読み込む時間を設けるのはどうか、と本書は提案している。
    目的は暗記することではなく、「見たことがあるかも...」という勘を得るため。
  - ライブラリのコードは、デバッグ、最適化、テストのプロセスを経過して生き延びたコード。
- （プログラム言語で書くのでなく）OS コマンドで実現するほうが適切でないか、考える。

# パート 4

## 14 章 テストと可読性

- テストは、読みやすく、メンテしやすいようにすべき。
  他の開発者がテストを見て、その挙動・仕様を把握しやすくするため。
  また、プロダクトコードを書き換えることやテストを追加することへの心理的障壁を少なくするため。
- 何をテストしているテストなのかがわかりやすいテスト名にすること。

## 15 章 [分/時間カウンター]の設計と実装

これまでの内容を活用し、分/時間カウンターを設計・実装。
