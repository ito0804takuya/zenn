---
title: "「Goならわかるシステムプログラミング」要点"
emoji: "🌟"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Go"]
published: false
---

# 書籍

https://www.lambdanote.com/collections/go-2/products/go-2

# 参考

コードを動かすために作ったレポジトリ。
https://github.com/ito0804takuya/go-sytem-programing

以前 Go を学習した際の自分の記事も参照。

# 第 1 章 Go 言語で覗くシステムプログラミングの世界

## 1.1 システムプログラミングとは

**システムプログラミングとは、OS の提供する機能を使ったプログラミング**。
（Web 関係のプログラミングとは対照的な場面で使われる言葉。）

### OS の機能

ボトムアップではレベルアップにつながる実感が湧きづらい OS の機能（下記）を、
プログラマー目線で、普段の開発にもフィードバックできるように見ていく。

- メモリの管理
- プロセスの管理
- プロセス間通信
- ファイルシステム
- ネットワーク
- ユーザー管理（権限など）
- タイマー

## 1.2 Go 言語

多くの OS の機能を直接扱える。
少ない行数で動くアプリケーションが作れる。

現在のシステムプログラミングでは主に C, C++が使われている。

- C, C++と比較したメリット
  - ライブラリの収集が簡単。
  - コンパイルで多くのエラーが見つかる。
  - 実行時のエラーがわかりやすい。
  - メモリ管理を注意深く設計しなくて済む。（ガベージコレクション）
  - コンパイルが速い。
- デメリット
  - （スクリプト言語よりは速いが）、C, C++と比較すると遅い。
  - バイナルサイズがかなり大きくなる。

:::details go mod init の解説

#### プロジェクト作成後の初期化

`mod init`を実行すると、go.mod ファイルが生成され、Go の処理系から、このファイルがある場所がこのプロジェクトのルートと認識される。

```bash
go mod init <プロジェクト名>
```

:::

## 1.4 デバッガーを使って "Hello World!"の裏側を覗く

`fmt.Println("Hello", "World!")`について、裏側でどういう処理が行われているか、関数の定義をたどっていくことで確認していく。
→ **最終的には、システムコールを呼び出している**ことが分かった。

#### システムコールとは（ざっくり）

- アプリケーションのプログラム単体では達成できない仕事を、OS のカーネルに依頼するために使う。
  （`syscall.Write()`では、（プログラムの外の世界である）ターミナルに対して文字列を出力するという仕事 を依頼している。）
- いくつも種類がある。

:::details 可変長引数関数

#### 可変長引数関数(Variadic function) `...`

メソッドの引数が、同じ型の複数個の場合、`...`(ドット 3 つ)で示す。

```go
func method(args ...Type)
```

- 参考記事 : https://zenn.dev/mikankitten/articles/cfa2ef834e338e

:::

:::details interface{}型

#### interface{}型

interface{}型は int, string, bool などと同じ、golang の型名。{}の部分まで含めて型名。
どんな型も格納できる特殊な型。

- 参考記事 : https://qiita.com/sh-tatsuno/items/0c32c01eaeaf2d726fdf

:::

# 第 2 章 低レベルアクセスへの入口 1：io.Writer

## 2.1 io.Writer は OS が持つファイルのシステムコールの相似形

OS は、システムコール（例えば 1 章の`syscall.Write()`）を呼び出すとき、ファイルディスクリプタ（`1`, `2`などの識別子）を指定する。
そうすることで、ファイルディスクリプタで指定したモノにアクセスできる。

ファイルディスクリプタに対応するモノには、ファイルのみならず、標準入出力・ソケットなどのファイルでないものも含まれ、ファイルと同じようにアクセスできる。
→ **ファイルディスクリプタは、色々なモノをファイルとしてアクセスできるように抽象化している**。

## 2.2 Go 言語のインタフェース

- `動名詞(その振る舞いの動詞 + er)`で命名することが多い。

## 2.3 io.Writer は「インタフェース」

OS のレイヤー（Go より下）では、ファイルディスクリプタを使って、色々なモノをファイルとして抽象化しているが、
Go のレイヤーでは、io.Writer インターフェースが抽象化して表現している。

```go
// os.File型
func (f *File) Write(b byte[]) (n int, err error) { ... }

// io.Writerインターフェース
type Writer interface {
	Write(b byte[]) (n int, err error)
}
```

:::message
インターフェースは、"どんなことができるか"を表現している。
（例: io.Writer は、何かを何かに書き込みするもの。）
:::

## 2.4 io.Writer を使う構造体の例

下記の構造体は io.Writer インターフェースを実装している。（`Write()`メソッドを持っている。）

- os.File : ファイルへ書き込み。
- os.Stdout, os.Stderr
- bytes.Buffer : バッファに書き込んで記録しておいて、後でまとめて取得。
- strings.Builder : bytes.Buffer の string 専用 ver.。
- net.Conn : 通信のコネクション。
- http.ResponseWriter : HTTP レスポンス。
  などなど

下記は、io.Writerに書き出す例。
- `fmt.Fprintf(io.Writer, 出力したい文字列, 文字列にてフォーマット出力するデータ)`

## 2.5 インタフェースの実装状況・利用状況を調べる
"*私（構造体）はこのインターフェースを実装しています*"ということは、構造体には記述しない。
とあるインターフェースを実装しているのか知りたい場合は、VSCodeの場合は、そのインターフェースを指定して"右クリック→実装へ移動"。

## 2.7 柔軟性が高く、パフォーマンスのよい設計のための Tips.
- データの入出力・加工を行う関数を書く場合、ファイル名やバイト列でなく、io.Readerやio.Writerを受け取るようにすると良い。

第 3 章 低レベルアクセスへの入口 2：io.Reader
　 3.1 io.Reader
　 3.2 io.Reader の補助関数
　 3.3 入出力に関する io.Writer と io.Reader 以外のインタフェース
　 3.4 io.Reader を満たす構造体で、よく使うもの
　 3.5 バイナリ解析用の io.Reader 関連機能
　 3.6 テキスト解析用の io.Reader 関連機能
　 3.7 io.Reader／io.Writer でストリームを自由に操る
　 3.8 本章のまとめと次章予告
　 3.9 問題

第 4 章 低レベルアクセスへの入口 3：チャネル
　 4.1 goroutine.
　 4.2 チャネル
　 4.3 システムからの通知
　 4.4 本章のまとめと次章予告
　 4.5 問題

第 5 章 システムコール
　 5.1 システムコールとは何か？
　 5.2 Go 言語におけるシステムコールの実装
　 5.3 POSIX と C 言語の標準規格
　 5.4 システムコールより内側の世界
　 5.5 Go 言語のシステムコールと POSIX
　 5.6 システムコールのモニタリング
　 5.7 エラー処理
　 5.8 通常のシステムコール以外の特殊なシステム呼び出し
　 5.9 本章のまとめと次章予告
　 5.10 問題

第 6 章 TCP ソケットと HTTP の実装
　 6.1 プロトコルとレイヤー
　 6.2 HTTP とその上のプロトコルたち
　 6.3 ソケットとは
　 6.4 ソケット通信の基本構造
　 6.5 Go 言語で HTTP サーバーを実装する
　 6.6 速度改善（1）: HTTP/1.1 の Keep-Alive に対応させる
　 6.7 速度改善（2）:圧縮
　 6.8 速度改善（3）:チャンク形式のボディー送信
　 6.9 速度改善（4）:パイプライニング
　 6.10 本章のまとめと次章予告

第 7 章 UDP ソケットを使ったマルチキャスト通信
　 7.1 UDP と TCP の用途の違い
　 7.2 UDP と TCP の処理の流れの違い
　 7.3 UDP のマルチキャストの実装例
　 7.4 UDP を使った実世界のサンプル
　 7.5 UDP と TCP の機能面の違い
　 7.6 本章のまとめと次章予告

第 8 章 高速な Unix ドメインソケット
　 8.1 Unix ドメインソケットの基本
　 8.2 Unix ドメインソケットの使い方
　 8.3 Windows の名前付きパイプ
　 8.4 Unix ドメインソケットと TCP のベンチマーク
　 8.5 ソケットのシステムコール小話
　 8.6 本章のまとめと次章予告

第 9 章 ファイルシステムの基礎と Go 言語の標準パッケージ
　 9.1 ファイルシステムの基礎
　 9.2 ファイル／ディレクトリを扱う Go 言語の関数たち
　 9.3 OS 内部におけるファイル操作の高速化
　 9.4 ファイルパスとマルチプラットフォーム
　 9.5 path/filepath パッケージの関数たち
　 9.6 本章のまとめと次章予告

第 10 章 ファイルシステムの最深部を扱う Go 言語の関数
　 10.1 ファイルの変更監視（syscall.Inotify\*）
　 10.2 ファイルのロック（syscall.Flock()）
　 10.3 ファイルのメモリへのマッピング（syscall.Mmap()）
　 10.4 同期・非同期／ブロッキング・ノンブロッキング
　 10.5 select 属のシステムコールによる I/O 多重化
　 10.6 FUSE を使った自作のファイルシステムの作成
　 10.7 本章のまとめと次章予告

第 11 章 コマンドシェル
　 11.1 シェルとは何か
　 11.2 シェルの利用形態
　 11.3 POSIX、SUS、LSB、BusyBox
　 11.4 環境変数
　 11.5 シェルがコマンドを起動するまで
　 11.6 Unix 哲学とシェル
　 11.7 まとめ

第 12 章 プロセスの役割と Go 言語による操作
　 12.1 プロセスに含まれるもの（Go 言語視点）
　 12.2 プロセスの入出力
　 12.3 自分以外のプロセスの名前や資源情報の取得
　 12.4 OS から見たプロセス
　 12.5 Go プログラムからのプロセスの起動
　 12.6 プロセスに関する便利な Go 言語のライブラリ
　 12.7 Go 言語では触れることのない世界
　 12.8 子プロセスの内部実装
　 12.9 本章のまとめと次章予告

第 13 章 シグナルによるプロセス間の通信
　 13.1 シグナルのライフサイクル
　 13.2 シグナルの種類
　 13.3 Go 言語におけるシグナルの種類
　 13.4 シグナルのハンドラを書く
　 13.5 シグナルの応用例（Server::Starter）
　 13.6 Go 言語ランタイムにおけるシグナルの内部実装
　 13.7 Windows とシグナル
　 13.8 本章のまとめと次章予告

第 14 章 Go 言語と並列処理
　 14.1 複数の仕事を同時に行うとは？
　 14.2 Go 言語の並列処理のための道具
　 14.3 スレッドと goroutine の違い
　 14.4 Go のランタイムはミニ OS
　 14.5 runtime パッケージの goroutine 関連の機能
　 14.6 RaceDetector
　 14.7 sync パッケージ
　 14.8 sync/atomic パッケージ
　 14.9 本章のまとめと次章予告

第 15 章 並行・並列処理の手法と設計のパターン
　 15.1 並行・並列処理の手法のパターン
　 15.2 Go における並行・並列処理のパターン集
　 15.3 本章のまとめと次章予告

第 16 章 Go 言語のメモリ管理
　 16.1 メモリ確保の旅
　 16.2 Go 言語の配列
　 16.3 スライスなど
　 16.4 ガベージコレクタ
　 16.5 本章のまとめと次章予告

第 17 章 実行ファイルが起動するまで
　 17.1 実行ファイルが起動するまで
　 17.2 実行ファイルを支える仕組み
　 17.3 実行ファイルのメモリ配置
　 17.4 Go のプログラムの起動
　 17.5 インタプリタでのコードの起動
　 17.6 まとめ

第 18 章 時間と時刻
　 18.1 OS のタイマー／カウンターの仕組み
　 18.2 さまざまな時間
　 18.3 時間に関するシステムコール
　 18.4 Go 言語で時間を扱う
　 18.5 時刻のフォーマット
　 18.6 本章のまとめと次章予告

第 19 章 Go 言語とコンテナ
　 19.1 仮想化
　 19.2 コンテナ
　 19.3 Windows Subsystem for Linux 2（WSL2）
　 19.4 libcontainer でコンテナを自作する
　 19.5 本章のまとめ
