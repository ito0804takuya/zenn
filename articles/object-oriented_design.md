---
title: "オブジェクト指向設計実践ガイド"
emoji: "📘"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["オブジェクト指向", "設計"]
published: false
---
# 書籍
https://gihyo.jp/book/2016/978-4-7741-8361-9

# Gitレポジトリ
書いたコードはGitレポジトリに保存。
https://github.com/ito0804takuya/object-oriented_design

# 1章　オブジェクト指向設計

## 設計
後の変更を容易にする行い。
コードの構成こそが設計。設計(コードの構成)は芸術である。
変更が容易なアプリケーションは、作るのも拡張するのも楽しい。

## オブジェクト指向設計
依存関係を管理すること。
##### オブジェクト
部品。
##### メッセージ
オブジェクト間で受け渡されるもの。相互作用。

## オブジェクト指向設計の道具
設計する際に設計者を助ける道具として、**原則**と**パターン**がある。
### 設計原則
#### SOLID
1. Single Responsibility Principle：**単一責任の原則**
2. Open/closed principle：**オープン/クロースドの原則**
3. Liskov substitution principle：**リスコフの置換原則**
4. Interface segregation principle：**インターフェース分離の原則**
5. Dependency inversion principle：**依存性逆転の原則**
:::message
本書のメイン。
:::
### デザイン(設計)パターン
いわゆる**GoF**
:::message alert
本書ではデザインパターンは解説していない。
:::

# 2章　単一責任のクラスを設計する
オブジェクト指向設計のシステムの基礎は（クラスでなく）**メッセージ**である。
(メッセージこそが設計の核だが、クラスのほうが分かりやすいので、クラスから解説している。)

## 変更が容易なコードに求められる性質 (TRUE)
#### 見通しが良い(Transparent)
  変更するコードも、そのコードに依存する別の場所のコードにおいても、**変更による影響が明白**であること。（影響範囲がわかるか）
#### 合理的(Reasonable)
  どんな変更であっても、**かかるコストは変更がもたらす利益にふさわしい**。（低コストか）
#### 利用性が高い(Usable)
  新しい環境、**予期していなかった環境**でも再利用できる。（どこでも動くか）
#### 模範的(Examplary)
  後からコードに変更を加える人が、上記の**品質を自然と保つようなコード**である。（他人を導くことができるか）

## なぜ単一責任が重要なのか
1. 責任が互いに結合しすぎて、必要な振る舞いだけを取り出すこと（再利用）ができないため。
2. 変更を加えるたびに、そのクラスに依存するクラスすべてを破壊する危険性があるため。

## クラスが単一責任かどうかを見極める
1. クラスメソッドを質問に言い換える。
  - 「Gearさん、この自転車のギアの比率を教えてくれますか？」→OK
  - 「Gearさん、この自転車のタイヤのサイズを教えてくれますか？」→NG
2. クラスの責任を1文で言い表す
  - 「自転車へのギアの影響を計算する」→OK
  - 「自転車へのギアの影響と、タイヤの円周を計算する」→NG

## 変更を歓迎するコードを書く
実際に変更が起こるかorどんな変更がおこるかは分からないが、容易に変更を受け入れられるコードを書くことは、将来的に大きな見返りとなる。
以下は、そのテクニック。

### データでなく、振る舞いに依存する
データへのアクセスは2つのどちらかの方法で行われるが、2.を使うようにする。
1. インスタンス変数を直接参照する
2. インスタンス変数をアクセサメソッドで包み隠す（ゲッタを経由させる）

#### インスタンス変数の隠蔽 (2.)
```ruby
class Gear
  # ゲッタを用意 → インスタンス変数の隠蔽
  attr_reader :chainring, :cog

  def initialize(chainring, cog)
    @chainring = chainring # チェーンリングの歯数
    @cog = cog # コグの歯数
  end

  # (以下略)
end
```
`attr_reader`や`attr_accessor`を使わない（ゲッタを用意しない）場合、例えば@cogを修正する必要が生じたとき、@cogの出現箇所すべてを修正する必要がある。
それに対し、`attr_reader`は裏で下記の実装をしてくれているため、1箇所だけの修正で変化に対応できる。
:::message
ゲッタを設けることで、(どこからでも参照される)**データ** → (1箇所で定義される)**振る舞い**に変わる。
:::
```ruby
def cog
  @cog # ここを修正すればいい
end
```
つまり、@cogというデータでなく、cogという振る舞い(アクセサメソッド)に依存するようにする。

## あらゆる箇所を単一責任にする

### メソッドから余計な責任を抽出する
（クラスと同様の理由で）メソッドも単一責任であるべき。
メソッドに対しても、その役割を1文で説明できるようにすること。

2つの責任を持っている。（直径の計算 + 繰り返し処理）
```ruby
# 複数のタイヤの直径をそれぞれ計算
def diameters
  wheels.collect { |wheel|
    wheel.rim + (wheel.tire * 2) # 直径 = リム+タイヤの厚み
  }
end
```

メソッドには単一の責任を持たせる。（直径の計算 , 繰り返し処理）
```ruby
# 複数のタイヤの直径を取得
def diameters
  wheels.collect { |wheel| diameter(wheel) }
end

# タイヤの直径を計算
def diameter(wheel)
  wheel.rim + (wheel.tire * 2) # 直径 = リム+タイヤの厚み
end
```

# 3章 依存関係を管理する
適切に設計されたオブジェクトは単一の責任を持つ。そのため、目的のためにはオブジェクト同士の共同作業が必要であり、共同作業をするにオブジェクトは他のオブジェクトを知っていないといけない。**「知っている」というのは依存**であり、しっかり管理する必要がある。

## 依存関係とは
クラス間に一定の依存関係が生まれるのは避けられないが、依存は最低限にするべき。（コードの合理性が失われるため）

以下のコードには、依存関係がある。（Wheelの変更によって、Gearの変更が強制される状況。）
```ruby
# 自転車のギア
class Gear
  attr_reader :chainring, :cog, :rim, :tire

  def initialize(chainring, cog, rim, tire)
    @chainring = chainring # チェーンリングの歯数
    @cog = cog # コグの歯数
    @rim = rim # リム(タイヤの内側の金属部分)の直径
    @tire = tire # タイヤの厚み
  end

  # ギアの比率(= ペダル1回転に対する車輪の回転数)
  def ratio
    chainring / cog.to_f # 浮動小数点へ変換
  end

  # ギアインチ(ギアと車輪の大きさが異なっても比較できる基準)
  def gear_inches
    # ギア比率 * タイヤの直径
    ratio * Wheel.new(rim, tire).diameter
  end
end

# 自転車の車輪
class Wheel
  attr_reader :rim, :tire

  def initialize(rim, tire)
    @rim = rim # リム(タイヤの内側の金属部分)の直径
    @tire = tire # タイヤの厚み
  end

  # タイヤの直径
  def diameter
    rim + (tire * 2) # 直径 = リム+タイヤの厚み
  end
end

puts Gear.new(52, 11, 26, 1.5).gear_inches
```

### オブジェクトが次のことを知っているとき、オブジェクトには依存関係がある。
- **他のクラスの名前**
  Gearは、Wheelという名前のクラスが存在することを知っている。
- **self以外のどこかに送ろうとするメッセージの名前**
  Gearは、Wheelのインスタンスがdiameterに応答することを知っている。
- **メッセージが要求する引数**
  Gearは、Wheel.newにrimとtireが必要なことを知っている。
- **引数の順番**
  Gearは、Wheel.newの第1引数がrimで、第2引数がtireである必要があることを知っている。

## オブジェクト間の結合
2つ以上のオブジェクトの結合が強固なとき、それらは1つのユニットであるように振る舞う。
つまり、1つだけを再利用する ということができない。

## 疎結合なコードを書く
### 依存オブジェクトの注入
```diff ruby
# 自転車のギア
class Gear
- attr_reader :chainring, :cog, :rim, :tire
+ attr_reader :chainring, :cog, :wheel

  def initialize(chainring, cog, rim, tire)
    @chainring = chainring # チェーンリングの歯数
    @cog = cog # コグの歯数
-   @rim = rim # リム(タイヤの内側の金属部分)の直径
-   @tire = tire # タイヤの厚み
+   @wheel = wheel # wheelオブジェクト
  end

  # ギアの比率(= ペダル1回転に対する車輪の回転数)
  def ratio
    chainring / cog.to_f # 浮動小数点へ変換
  end

  # ギアインチ(ギアと車輪の大きさが異なっても比較できる基準)
  def gear_inches
    # ギア比率 * タイヤの直径
-   ratio * Wheel.new(rim, tire).diameter
+   ratio * wheel.diameter
  end
end

- puts Gear.new(52, 11, 26, 1.5).gear_inches
+ puts Gear.new(52, 11, Wheel.new(26, 1.5)).gear_inches # Gearが依存しているWheelオブジェクトを注入
```
依存が削減され、今は**wheelがdiameterメソッドに応答することだけ知っている(1つだけ依存を残している)状況**に改善。

### 外部メッセージを隔離する
gear_inchesの`wheel.diameter`は、Gearにおいては**外部メッセージ**。
```ruby
def gear_inches
  # ギア比率 * タイヤの直径
  ratio * wheel.diameter # selfへのメッセージ+外部メッセージ (外部メッセージが含まれている)
end
```
今は簡素なコードだから良いが、gear_inchesが複雑になるほどこの外部メッセージによって変更が必要になる可能性(壊れる危険性)が高くなる。
そこで、gear_inches内の**外部的な依存を取り除くため、専用のメソッド内にカプセル化する**。
```ruby
def gear_inches
  ratio * diameter # selfへのメッセージのみ
end

def diameter
  wheel.diameter # 外部メッセージ
end
```

### 引数の順番への依存を除去する
引数が必要なメッセージを送るとき、引数を「正しい順番」で渡す必要がある場合、それは**引数の順番に依存している**。
```ruby
# 第1引数はchainringで, 第2引数はcog, 第3引数はwheel であることを知っている必要がある
Gear.new(52, 11, Wheel.new(26, 1.5))
```

:::message alert
本書では「引数をハッシュで渡すテクニック」が紹介されていたが、今は**キーワード引数**があるので、キーワード引数を使うほうがいい。
（調べたところ、本書が2016年出版で、キーワード引数は2017年に導入されたので、タイミングが悪かったのだと思われる。）
:::

```ruby
Gear.new(chainring: 52, cog: 11, wheel: Wheel.new(26, 1.5))
```

## 依存方向の管理
依存関係には常に方向がある。依存方向の決め方を知る。

### 依存方向の選択
#### 結論 : 「自身よりも変更されないもの」に依存すること
#### 見定め方・考え方
- そのクラスは他のクラスより**要件が変わりやすいか**。
  （変わりにくいものの例：Rubyの基本的なクラス、フレームワークのコード）
- **具象クラスは**、抽象クラスより**変わる可能性が高い**。
  （抽象化されたものへの依存は、具象的なものへの依存よりも常に安全。）
- 多くから依存されているクラスを変更すると、広範囲に影響がでる。

# 4章 柔軟なインターフェイスをつくる
オブジェクト指向のアプリケーションはクラスから成り立つが、メッセージによって定義される。
設計では、オブジェクト間で受け渡されるメッセージについても考慮しなければならない。
→オブジェクトが何を知っているか（責任）や、誰を知っているか（依存関係）だけでなく、**オブジェクトが互いにどうやって会話するか**の設計が必要。
→オブジェクト間の会話はオブジェクトのインターフェイスを介して行われる。

## インターフェイスを定義する
レストランを例にして表現。
- レストランの厨房 = プライベートなメソッド
  プライベートなメッセージが数多く受け渡されている
- メニュー表 = インターフェイス
  パブリックなメッセージ
- お客さん = オブジェクト
  どのように料理が作れられているか（処理が行われているか）は知らなくていい。

クラス内の**パブリックなメソッドは安定した部分**であり、**プライベートなメソッドは変化し得る部分**。

### より良いインターフェイス
本書では、自転車旅行を提供する旅行会社のシステムを例にしている。
=

#### 参加者(Customer)と旅行(Trip)のメッセージ
Customer → suitable_trips() → Trip