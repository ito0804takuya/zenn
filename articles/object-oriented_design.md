---
title: "オブジェクト指向設計実践ガイド"
emoji: "📘"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["オブジェクト指向", "設計"]
published: false
---
# Gitレポジトリ
書いたコードはGitレポジトリに保存。
https://github.com/ito0804takuya/object-oriented_design

# 1章　オブジェクト指向設計

## 設計
後の変更を容易にする行い。
コードの構成こそが設計。設計(コードの構成)は芸術である。
変更が容易なアプリケーションは、作るのも拡張するのも楽しい。

## オブジェクト指向設計
依存関係を管理すること。
##### オブジェクト
部品。
##### メッセージ
オブジェクト間で受け渡されるもの。相互作用。

## オブジェクト指向設計の道具
設計する際に設計者を助ける道具として、**原則**と**パターン**がある。
### 設計原則
#### SOLID
1. Single Responsibility Principle：**単一責任の原則**
2. Open/closed principle：**オープン/クロースドの原則**
3. Liskov substitution principle：**リスコフの置換原則**
4. Interface segregation principle：**インターフェース分離の原則**
5. Dependency inversion principle：**依存性逆転の原則**
:::message
本書のメイン。
:::
### デザイン(設計)パターン
いわゆる**GoF**
:::message alert
本書ではデザインパターンは解説していない。
:::

# 2章　単一責任のクラスを設計する
オブジェクト指向設計のシステムの基礎は（クラスでなく）**メッセージ**である。
(メッセージこそが設計の核だが、クラスのほうが分かりやすいので、クラスから解説している。)

## 変更が容易なコードに求められる性質 (TRUE)
#### 見通しが良い(Transparent)
  変更するコードも、そのコードに依存する別の場所のコードにおいても、**変更による影響が明白**であること。（影響範囲がわかるか）
#### 合理的(Reasonable)
  どんな変更であっても、**かかるコストは変更がもたらす利益にふさわしい**。（低コストか）
#### 利用性が高い(Usable)
  新しい環境、**予期していなかった環境**でも再利用できる。（どこでも動くか）
#### 模範的(Examplary)
  後からコードに変更を加える人が、上記の**品質を自然と保つようなコード**である。（他人を導くことができるか）

## なぜ単一責任が重要なのか
1. 責任が互いに結合しすぎて、必要な振る舞いだけを取り出すこと（再利用）ができないため。
2. 変更を加えるたびに、そのクラスに依存するクラスすべてを破壊する危険性があるため。

## クラスが単一責任かどうかを見極める
1. クラスメソッドを質問に言い換える。
  - 「Gearさん、この自転車のギアの比率を教えてくれますか？」→OK
  - 「Gearさん、この自転車のタイヤのサイズを教えてくれますか？」→NG
2. クラスの責任を1文で言い表す
  - 「自転車へのギアの影響を計算する」→OK
  - 「自転車へのギアの影響と、タイヤの円周を計算する」→NG

## 変更を歓迎するコードを書く
実際に変更が起こるかorどんな変更がおこるかは分からないが、容易に変更を受け入れられるコードを書くことは、将来的に大きな見返りとなる。
以下は、そのテクニック。

### データでなく、振る舞いに依存する
データへのアクセスは2つのどちらかの方法で行われるが、2.を使うようにする。
1. インスタンス変数を直接参照する
2. インスタンス変数をアクセサメソッドで包み隠す（ゲッタを経由させる）

#### インスタンス変数の隠蔽 (2.)
```ruby
class Gear
  # ゲッタを用意 → インスタンス変数の隠蔽
  attr_reader :chainring, :cog

  def initialize(chainring, cog)
    @chainring = chainring # チェーンリングの歯数
    @cog = cog # コグの歯数
  end

  # (以下略)
end
```
`attr_reader`や`attr_accessor`を使わない（ゲッタを用意しない）場合、例えば@cogを修正する必要が生じたとき、@cogの出現箇所すべてを修正する必要がある。
それに対し、`attr_reader`は裏で下記の実装をしてくれているため、1箇所だけの修正で変化に対応できる。
:::message
ゲッタを設けることで、(どこからでも参照される)**データ** → (1箇所で定義される)**振る舞い**に変わる。
:::
```ruby
def cog
  @cog # ここを修正すればいい
end
```
つまり、@cogというデータでなく、cogという振る舞い(アクセサメソッド)に依存するようにする。

## あらゆる箇所を単一責任にする

### メソッドから余計な責任を抽出する
（クラスと同様の理由で）メソッドも単一責任であるべき。
メソッドに対しても、その役割を1文で説明できるようにすること。

2つの責任を持っている。（直径の計算 + 繰り返し処理）
```ruby
# 複数のタイヤの直径をそれぞれ計算
def diameters
  wheels.collect { |wheel|
    wheel.rim + (wheel.tire * 2) # 直径 = リム+タイヤの厚み
  }
end
```

メソッドには単一の責任を持たせる。（直径の計算 , 繰り返し処理）
```ruby
# 複数のタイヤの直径を取得
def diameters
  wheels.collect { |wheel| diameter(wheel) }
end

# タイヤの直径を計算
def diameter(wheel)
  wheel.rim + (wheel.tire * 2) # 直径 = リム+タイヤの厚み
end
```