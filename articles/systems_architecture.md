---
title: "現場で役立つシステム設計の原則"
emoji: "🕌"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["設計"]
published: false
---

# 1. 小さくまとめてわかりやすくする
## 設計とは
どこに何が書いているのかわかりやすくすること。
（そうすることで、変更や拡張が楽で安全になるコードを生み出すように導く。）

## プログラムの変更が楽になる基本テクニック
- わかりやすい名前を使う。（**名前重要**）
- 意味のかたまりごとに改行する。
- 目的ごとに変更を用意する。（**説明用変数**の導入）
  - 1つの変数に使いまわさない。（= 破壊的代入をしない。）
  - 変更の影響範囲を小さくできる。
- メソッドに切り出す。（**メソッドの抽出**）
- **異なるクラスの重複したコードを無くす**。
- **狭い関心事に特化したクラスにする**。
- **メソッドは短く**。**クラスは小さく**。

## 値オブジェクト
### 基本データ型の落とし穴
- 基本データ型では扱える範囲が広すぎて、アプリケーションにとって適切でない場合がある。
  （例：intは、マイナス21億〜21億までの整数）
  **値を扱うためのクラス**（**値オブジェクト**）を定義して、範囲外の値は異常値としてエラーにする等、適切な範囲の値を取り扱う。
:::message
業界の用語をそのままクラス名やメソッド名に使うと、プログラムが業務の説明書になる。
:::

### 値オブジェクトは不変にする
- インスタンス変数はコンストラクタで（インスタンス生成時に）設定。
- インスタンス変数を変更するメソッド（setter）を作らない。
- 別の値が必要になったら、別のオブジェクトを作成する。

## コレクションオブジェクト
### 複雑さを閉じ込める
- コレクション型のデータとロジックを特別扱いにして、**コレクションを1つだけ持つ専用クラス**（**コレクションオブジェクト**）を作る。
  - 値オブジェクトと同じように、コレクションオブジェクトも不変にする。
:::message
**コレクションオブジェクトは**、たいていの場合**業務の関心事**そのもの。
:::

# 2. 場合分けのロジックを整理する
場合分けのコードは、プログラムを複雑にする。
## else句を使わない
- else句をなくすと条件分岐が単純になる。
  - else句を使わず早期リターンする。（ガード節）
- 複文は単文に分ける。
  - else句を使わずに独立性の高い単文を書く。
## インターフェース
- 区分ごとのロジックを別クラスに分ける。
  - インターフェースを用いてポリモーフィズム（多態性 = 別のクラスを同じ型として扱えるようにする）を実現する。
  - クラス間は、互いを知らないほど良い。結合が弱くなり（独立性が高くなり）、変更による別クラスへの影響が減る。
## enum
- 列挙型（enum）を使い、区分定数の一覧を宣言する。
  - ポリモーフィズムは、区分の一覧がわかりにくいという問題があるため。
  - 区分オブジェクト：enumを使って区分ごとのロジックをわかりやすく整理する方法。
- Javaの場合、EnumSetで状態遷移表を表現できる。
:::message
- インターフェースを使い、使う側のクラスが区分ごとのクラスの影響を受けにくくする。
- enumを使い、業務で扱う区分の一覧を宣言することで、業務ロジックの見通しを良くし、わかりやすく整理する。
:::

# 3. 業務ロジックをわかりやすく整理する
## ドメインオブジェクト
### 業務ロジックを、データを持つクラスに集める
↑はオブジェクト指向の基本。
- 手続き型の設計：データクラス（データ構造）と機能クラス（処理手順）に分ける。
- オブジェクト指向：データとロジックを1つのクラスにまとめる。コードの重複や散在を防ぐ。

### メソッド
- **データを持つクラスのメソッドは、ロジックの置き場所**。
- インスタンス変数を返すだけの`getter`メソッドは(基本)書かない。
  こういうメソッドには何らかの計算/加工/判断をさせる任務を与えることを考える。
- メソッドはインスタンス変数を必ず使う。使わない場合はメソッド（ロジック）の置き場所を再検討すべき。

### クラス
- クラスが肥大化したら、**関連性の高いデータとロジックを抜き出して、新しいクラスに分ける**ことを考える。
- 凝集度が高いクラスを作ることが、オブジェクト指向の基本。
  独立性が高く、再利用性が高い。他のクラスへ影響を与えづらい（= 疎結合）。
  - 凝集：「切っても切れない」密接な関係。

### パッケージ
クラスの数が増えたときの整理の手段として、パッケージがある。
- 関連性の強いクラスは同じパッケージに集める。（= クラス郡を作る。）
- パッケージ内のクラスやメソッドのスコープは、できる限りパッケージ内に留める。（= publicにしない。）

:::message
オブジェクト指向の設計は、改善の繰り返し。
**コードを書いて動かしてみながら、改善を続け、より良い設計を見つけていく**。
:::

## ドメインモデル
- ドメインをモデリング（抽象化）したもの。
  （ドメインモデルを実装したものが、ドメインオブジェクト。）
- ドメインモデルを見れば、業務全体がどういった関心事から成り立っているのか理解できる。

## 3層 + ドメインモデル
業務ロジックはドメインモデルにのみ記述。
業務的な知識が必要な判断/加工/計算について、3層はドメインオブジェクトに任せる。
- 3層
  - プレゼンテーション層：外部との入出力。（UIなど）
  - アプリケーション層：マクロな手順。（業務フローなど）
  - データソース層：データの入出力。（データベースなど）
- ドメインモデル：業務データと業務ロジックを表現したドメインオブジェクトの集合。

:::message
ドメインモデルは業務の説明書。
:::

# 4. ドメインモデルの考え方で設計する
## ドメインモデルを開発する工程
- 分析：人間のやりたいことを正しく理解する
  - 要求の聞き取り
  - 不明点を確かめるための会話
  - 図や表を使っての整理
  - 理解した結果を記録する文書の作成
- 設計：人間のやりたいことをソフトウェアとして実現する方法を考える
  - パッケージ構成と名前
  - クラス構成と名前
  - メソッド構成と名前

:::message alert
#### よくある失敗
クラス名に、実際の業務に使われていない抽象的な言葉を使う。
:::

## ドメインモデルの作り方
#### 1. 部分を作りながら全体を組み立てていく
  ここの部品（ドメインオブジェクト）を作り、それを組み合わせながら全体を作っていく。
#### 2. 全体と部分を行ったり来たりしながら作る
  部分だけに目を向けず、全体として間違った方向に進んでいないか確認しながら。
  全体を俯瞰するためのツールとして、パッケージ図・業務フロー図がある。
#### 3. 重要な部分から作っていく
  重要な部分とは、間違いなく必要な部分。
  オブジェクトは独立性の高い部品なので、**単体として動作し、テストできる**。
#### 4. 独立した部品を組み合わせて、機能を実現する
  作ったドメインオブジェクトを組み合わせて、**アプリケーション層で機能を実現**。

## ドメインオブジェクトの見つけ方
業務の関心事を、**ヒト/モノ/コトに3分類**する。
  - ヒト：業務活動の当事者。行動する主体。
  - モノ：関心の対象。物理的なモノ + 概念的なモノ。
  - コト：事象。基本的に**ヒトの意思決定や行動の結果**。

**コトに注目して整理すると効果的**。
- コトは、**ヒトとモノとの関係**であるため、関心事を特定しやすくなる。
- コトは、**時間軸の前後関係**を持つため、全体の流れや重要な前後関係が明確になる。

## ドメインモデル活用の基本パターン
アプリケーション層のクラスには、業務的な判断ロジックが増えがち。（= 「ちょっとしたif文」を書いてしまいがち。）
これでは、手続き型のトランザクションスクリプトになってしまう。

こうなる原因は、**どういうドメインオブジェクトがあれば楽にプログラムを書けるか**というイメージが持てないため。
下記のパターンを体で覚えるのが近道。

:::message
**`ドメインオブジェクトの基本の設計パターン`を組み合わせて、
`業務の関心事のパターン`に沿って業務ロジックを分類して整理していく**と、
自然とアプリケーション層でなくドメインモデルに業務ロジックの大半が集まる。
:::

**<ドメインオブジェクトの基本の設計パターン>**
| ドメインオブジェクト | 設計パターン |
| - | - |
| 値オブジェクト | 基本データ型（数値、文字列、日付）をラッピングしてロジックを整理する。 |
| コレクションオブジェクト | 配列やコレクションをラッピングしてロジックを整理する。 |
| 区分オブジェクト | 区分の定義と、区分ごとのロジックを整理する。 |
| enumの集合操作 | 状態遷移ルールなどをenumの集合として整理する。 |

**<業務の関心事のパターン>**
| 関心事のパターン | 業務ロジックの内容 |
| - | - |
| 口座(Account)パターン | 現在の値（残高）を表現し、 妥当性を管理。 |
| 期日(DueDate)パターン | 約束の期日と判断を表現。 |
| 方針(Policy)パターン | 色々なルールが存在する、複雑なロジックを表現。 |
| 状態(State)パターン | 状態と、状態遷移を表現。 |

## 改善ポイント
ドメインオブジェクトは一度作って完成 ではない。アプリケーションの部品としての使い勝手を確認しながら改善を続ける。
- クラス名、メソッド名の変更
- ロジックの移動
- 取りまとめ役クラスの導入

## 業務の言葉とコードを一致させる
- 役立つドメインオブジェクトは、クラス名やメソッド名がそのまま業務の言葉と一致する。
- ソースコードで業務の要求仕様を表現（= 自己文書化）することで、プログラムの変更を容易にする。
:::message
開発者は、業務知識を学び、理解する必要がある。
**業務を学びながら、早い段階から実際にコードを書いて、段階的にコードを成長させていく**のが、ドメインモデル設計の効果的な方法。
:::

## 業務の理解
#### 業務の基本知識を身につける方法
1. マニュアルや利用者ガイドを読む。
2. 一般的な知識を書籍などで勉強する。
3. その業務で使われる画面やファイルを調べる。
4. 形式的なドキュメントよりも、図（業務フロー図など）を使って関係性を整理する。
5. 業務の専門家と会話する。
6. 自分の理解が正しいか、業務の専門家に確認する。
:::message
業務を正しく理解した開発チームが設計したドメインモデルは、**業務知識の体系**となる。
:::

# 5. アプリケーション機能を組み立てる
## サービスクラス
- 3層 + ドメインモデルの設計において、アプリケーション層はサービスクラスと呼ばれる。
- サービスクラスの記述はごちゃごちゃしがち。そうならないように、下記を徹底する。
  - **業務ロジックは**、サービスクラスに書かずに**ドメインオブジェクトに任せる**。
    （**サービスクラスで判断/加工/計算しない**）
  - **画面の複雑さを、サービスクラスに持ち込まない。**
  - データベースの入出力の都合から、サービスクラスを独立させる。
- **意味のある最小単位**かつ**単独でテスト可能な単位**に、**メソッドを分割する**のがサービスクラス設計の基本。

## シナリオクラス
- 複数の処理を一連で行いたい場合、小さく分けたサービスクラスを組み合わせて、シナリオクラスを作る。
　（サービスクラスのみでは実現できないため。）
  - 【例】預金を引き出す機能
    ①残高が不足していないことを確認。
    ②残高を更新。
    ③更新後の残高を照会する。
- 小さく分かれているサービスクラスは、それ単独でも使用できるため、利用性が高い。
  （残高を照会する機能だけを使う 等）

## 契約による設計
- サービスを利用する側と提供する側とで、サービス提供における約束事を決め、設計をシンプルに保つ技法。
  - 対照的な技法：防御的プログラミング
    利用する側が何をしてくるかわからないという前提で、様々な防御的なロジックを書く手法。
- 基本的な約束事は下記。
  - **nullを渡さない/返さない**。
  - **状態に依存する場合、使う側が事前に確認**する。
  - 約束を守った上でさらに異常が起きた場合、**例外で通知**する。
:::message alert
例外を使うのは、通常ではあまり起こらない場合に限る。
:::

## リポジトリ
- データの入出力はアプリケーションの重要な部分。
  ただし、データベース操作の手順と業務ロジックは別物であり、**データベースの入出力手順（手続き）を並べるプログラムは、業務的な意図が読み取りにくくなる**。
- **情報の記録と参照**（※）は、**業務の関心事**。
  データベースの単なるCRUD操作は、業務の関心事ではない。
- ※を実現するドメインオブジェクトの保管と取り出しができる（仮想の）収納場所を、リポジトリとして宣言する。
- リポジトリを使うことで、データベース操作の詳細をサービスクラスに意識させなくて済む。
  - 【例】注文を記録する機能
    注文テーブルと注文明細テーブルにINSERTが必要だとしても、注文を記録するという業務の関心事とは関係ない。
    こういったテーブル設計に依存する心配事は、業務機能を記述するサービスクラスには不要。
  - リポジトリインターフェースの背後に隠すことで、サービスクラスは業務の関心事だけに専念できる。（= シンプルな記述にできる。）

# 6. データベースの設計とドメインオブジェクト
## 悪いテーブル設計
**プログラムが分かりにくく複雑になっている原因**が、**データベース設計やデータ内容の問題**であることがよくある。
- データの妥当性を判定したり、例外的なデータを扱うための処理などにif文が増える。
- テーブル定義やデータ内容に現れない暗黙の知識が大量に必要になる。
- SQLが複雑になりがち。

### 用途がわかりにくいカラム
- カラム名が省略形
- NULLが入っているカラム
- 他のカラムの値によって値の意味が変わるカラム
- カラムから取得した値を、プログラムで分解する必要がある
- 意味が読み取れないコード（1, 2, 3...などのマジックナンバー）

### 色々な用途に使う巨大テーブル
カラム数が多い巨大なテーブル。
- 似たようなカラムが多く、使い分けがわからない
- NULL値が多い

### テーブルの関係がわからない
- 外部キー制約がない
- キーとなるカラム名に一貫性がない

--- 

## 良いテーブル設計
### 名前を省略しない
意味の明確な、共通の単語を使う。

### 適切なデータ型を使う。
データ型と桁数を適切に制限する。

### 制約を必ず使う
#### NOT NULL制約
NOT NULL制約で、良いテーブル設計へ導く。
- **カラムにはNULLを含めないのが、データベース設計の基本**。
  （NULLは演算不能を意味する。SQLやプログラムでNULLを想定しないといけなく、意図しない挙動になる or 複雑になる。それらがバグの原因になるため。）
- **カラムは全てNOT NULLにする**。
  **どうしてもNULLが必要であれば、別のテーブルに分ける**ことを考える。こうすることで**正規化が進む**。

#### UNIQUE(一意性)制約
UNIQUE制約で、**データの重複を防ぐ**。
（`UNIQUE`と`PRIMARY`は似ているが別物。）

#### 外部キー制約
外部キー制約で、**テーブル間の関係を明確に**する。

### 正確に記録するための3つの工夫
1. 記録のタイミングが異なるデータはテーブルを分ける
NULL可能なカラムが必要になってしまうため。
:::message alert
【意見】参照頻度・パフォーマンスへの影響による と思う。
:::
2. 記録の変更を禁止する
UPDATE文を使わない。
- 方法1: 過去データは残す。取り消しデータと新データをINSERT。
- 方法2: 過去データはDELETE。新データをINSERT。
:::message alert
【意見】ここは丸呑みしない。変更（更新）を許可するかどうかは、設計の段階で判断すべき。
:::
3. カラムの追加はテーブルを追加する
そのカラムには過去のデータが存在せず、NULLを許容しないといけないため。
:::message alert
【意見】
過去のデータに対して、デフォルト値が明確に決まっている等でNULLが存在しない状態にできるなら良いと思う。
基本的には*カラムの追加はテーブルを追加する*のが良い ということ。
:::

### 参照をわかりやすくする工夫
#### 状態テーブル
- 銀行の残高など、理論的に導出できる値であっても、その都度算出するのはロジックが複雑になり性能面でも問題となることがある。
  これは、状態テーブル（= この例で言うと残高テーブル）を追加することで解消できる。
  （DBのインデックスは、これと同じようなことをしている。2次的なインデックス情報を生成して、検索性能を向上させている。）
- この残高の更新は同時でなくても良い。（= 同一トランザクションで処理しなくていい。）

#### イベントソーシング
コトの記録を唯一の情報源（トリガー）として、そこから派生する様々な情報を目的別に記録する方針。
  （非同期メッセージングで、分散型で非同期的に処理する。）

- システム間の連携を疎結合にしやすい。
- 個々の機能は、自分の担当領域だけを処理するシンプルなプログラムにできる。
- 厳密な即時性や、データ間の整合性を保証するには、それなりの仕組みが必要になる。
  非機能要求な運用面からは、検討すべき課題が多いのが実情。

【例】
  - コトの発生を顧客管理サーバに通知すると、顧客管理サーバは顧客単位の残高を更新する。
  - コトの発生を営業管理サーバに通知すると、営業管理サーバは売上高を更新する。

## オブジェクトの設計とテーブルの設計
- オブジェクトとテーブルは似てくるが、**似ているだけで別物**。
  設計のアプローチや、設計を変更する動機が本質的に異なる。
  - 設計のアプローチとして、**オブジェクトは部分から全体**に、**テーブルは全体から部分**を考えて設計する。
- オブジェクトとテーブルは別々に設計し、業務の関心事の表現として正しくマッピングすることが大切。

# 7. 画面とドメインオブジェクトの設計を連動させる
## 画面アプリケーションの開発の難しさ
- 画面にはさまざまな利用者の関心事が詰め込まれる。
- 画面単位でロジックを埋め込む、画面単位のプログラム（画面に引きづられた設計）は変更を大変にする。
  - 表示のためのロジックと業務ロジックが混在してしまう。
  - 複数の画面に同じコードが重複してしまう。
- 複雑で変更がやっかいになる理由
  - 1. 画面そのものが複雑
    → **何でもできる汎用画面でなく、用途ごとのシンプルな画面に分ける**。
      （**タスクベースのインターフェース**：用途を特定した小さな単位の画面）
  - 2. 画面の表示ロジックと業務ロジックが分離できていない。
    → 画面まわりのロジックから業務ロジックを分離する。
:::message
関心事を分けることが重要。（さまざまな関心事を詰め込みすぎない。）
:::

## 画面とドメインオブジェクトの連動
### タスクベースのインターフェースの場合
- ドメインオブジェクトをそのまま使う。
- `画面の関心事`と`ドメインオブジェクトで表現する関心事`は一致するのが基本。
  - 一致しない場合、ドメインオブジェクトの設計 or 画面のデザイン を見直す必要があるかもしれない。

### 複数の関心事が混在している「何でも画面」の場合
- ビュー専用のオブジェクトを、プレゼンテーション層に用意。
  ビュー専用のオブジェクトの中で、複数のドメインオブジェクトを組み合わせる。

## ビューとモデルの分離

### 1. 論理的な情報構造は、ドメインオブジェクトで表現する
#### ビューに書くべきこと
- 物理的なビュー : 画面を表示する技術方式に依存したビューの表現。（物理的な手段）
  - `HTMLタグ`、`改行コード` など
#### ドメインオブジェクトに書くべきこと
- 論理的なビュー : 技術方式に依存しない概念的な構造。
  - `段落がいくつあるか`、`文字数`、`長文は最初の20文字だけ表示する`、`千円単位でカンマを付ける` など

### 2. 場合ごとの表示の違いは、ドメインオブジェクトで出し分ける
- 画面表示でif文を使っている場合は、それをドメインオブジェクトに移動できないか検討する。
  それを修正するときに多数の修正が必要になるため。1箇所に集約し、閉じ込めやすくなる。
:::message alert
【意見】フロントで関数化してもいい場面はありそう。
:::

## 視覚表現
### 画面項目の並び順
画面での項目の並び順と、対応するドメインオブジェクトのフィールドの並び順は一致させる。
### 画面項目のグルーピング
| 原則 | 説明 | ドメインオブジェクトとの連動 |
| - | - | - |
| 近接 | 関係のある情報を近づける。 | 画面デザイン上、離してある情報が、1つの<br>ドメインオブジェクトにまとまっているのは問題。 |
| 整列 | 同じ意味なら同じラインに揃える。<br>異なれば異なるラインに揃える。 | インデントされている場合は、<br>意味として異なるということ。 |
| 対比 | 意味の重みの違いを<br>文字の大きさや色で区別する。 | 重要な項目はクラス内の上部で宣言する。<br>弱く表現されている項目は別のクラスを作って隠蔽するのも検討。 |
| 反復 | 同じ意味は<br>同じパターンで視覚化する。 | 同じ型のオブジェクトで表現する。<br>・1つのクラスの別々のオブジェクト<br>・インターフェースで同じ型で宣言されている、複数のクラスのオブジェクト |
（画面デザインの4原則 参考サイト：https://umuco.jp/design-4/）

## 利用者向け情報
（画面と同じく）利用者向け情報も、利用者の関心事を表現している。
- プレスリリース：ソフトウェアの特徴、セールスポイント が記載されている。
- リリースノート：変更点 が記載されている。
- **利用者ガイド**：開発時に作られた仕様書よりも、利用者ガイドは**メンテ・改善されることが多く、ソフトウェアの仕様を正しく表現している可能性が高い**。

# 8. アプリケーション間の連携
## アプリケーションを連携する4つの方法
1. ファイル転送
2. データベース共有
3. WebAPI
4. メッセージング：メッセージング基盤を使って非同期にデータを送る

## WebAPI
### 標準
- データ形式：JSON or XML
- 文字コード：UTF-8

### PUT, DELETEはPOSTに
- PUT, DELETEは、できるだけPOSTに置き換えて、GETと組みあわせるほうが良い。
  （データの登録と相手の状態を同時に扱うPUT → POSTによる登録 + GETによる状態の取得）
  - PUT, DELETEは、APIを使う側が、APIを提供する側のリソースの識別体系を事前に知っている必要があるため。
    （アプリケーション間の依存性を強くし、密結合になってしまう。）

### エラー時の約束事
- 500番台のエラーの場合、エラー内容は詳細にすべきではない。
  - APIを使う側にとって不要な情報なため。
  - セキュリティ的に保護すべき内容が含まれるリスクがあるため。

### 良いAPIとは
APIで重要なのは、色々なアプリケーションを組み立てるために役立つこと。
組み立てやすく変更しやすい、**適度な粒度**に分割されている部品(API)が使いやすい。

### APIの設計原則
#### 登録と参照は別のAPIにする
【例】何かを予約するAPI
- ✕　POSTのレスポンスとして、予約内容の詳細を返す
  - WebAPIでなく、Webサービスの発想。
- ◯　POSTのレスポンスとして、予約番号だけを返し、予約内容はその予約番号を使って別途GETする
  - 柔軟なアプリケーションを組み立てられる。
#### リソースの単位を分ける
より小さな単位のデータを取得・登録できるAPIを提供する方法もある。

【例】
- 名前だけを取得：`GET members/1234/name`
- 名前だけを更新：`POST members/1234/name`

### バージョン管理
古いAPIを廃止する場合、一定の移行期間を設けて段階的に廃止する。
【例】
1. 新しいAPIを追加。互換性のため、古いAPIも提供を続ける。
2. 古いAPIでは`303 See Other`を返すよう変更。
3. 古いAPIでは`404 Not Found`を返すよう変更。
4. 古いAPIを削除。

### APIを複合したサービス
複合サービスの提供は、アプリケーション間の結合度を上げてしまい、お互い（利用者・提供者）のアプリケーションの成長や、APIの修正・拡張の障害になる。
そのため、可能な限り、複合サービスは`APIを利用する側`が開発すべき。