---
title: "現場で役立つシステム設計の原則"
emoji: "🕌"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["設計"]
published: false
---

# 1. 小さくまとめてわかりやすくする
## 設計とは
どこに何が書いているのかわかりやすくすること。
（そうすることで、変更や拡張が楽で安全になるコードを生み出すように導く。）

## プログラムの変更が楽になる基本テクニック
- わかりやすい名前を使う。（**名前重要**）
- 意味のかたまりごとに改行する。
- 目的ごとに変更を用意する。（**説明用変数**の導入）
  - 1つの変数に使いまわさない。（= 破壊的代入をしない。）
  - 変更の影響範囲を小さくできる。
- メソッドに切り出す。（**メソッドの抽出**）
- **異なるクラスの重複したコードを無くす**。
- **狭い関心事に特化したクラスにする**。
- **メソッドは短く**。**クラスは小さく**。

## 値オブジェクト
### 基本データ型の落とし穴
- 基本データ型では扱える範囲が広すぎて、アプリケーションにとって適切でない場合がある。
  （例：intは、マイナス21億〜21億までの整数）
  **値を扱うためのクラス**（**値オブジェクト**）を定義して、範囲外の値は異常値としてエラーにする等、適切な範囲の値を取り扱う。
:::message
業界の用語をそのままクラス名やメソッド名に使うと、プログラムが業務の説明書になる。
:::

### 値オブジェクトは不変にする
- インスタンス変数はコンストラクタで（インスタンス生成時に）設定。
- インスタンス変数を変更するメソッド（setter）を作らない。
- 別の値が必要になったら、別のオブジェクトを作成する。

## コレクションオブジェクト
### 複雑さを閉じ込める
- コレクション型のデータとロジックを特別扱いにして、**コレクションを1つだけ持つ専用クラス**（**コレクションオブジェクト**）を作る。
  - 値オブジェクトと同じように、コレクションオブジェクトも不変にする。
:::message
**コレクションオブジェクトは**、たいていの場合**業務の関心事**そのもの。
:::

# 2. 場合分けのロジックを整理する
場合分けのコードは、プログラムを複雑にする。
## else句を使わない
- else句をなくすと条件分岐が単純になる。
  - else句を使わず早期リターンする。（ガード節）
- 複文は単文に分ける。
  - else句を使わずに独立性の高い単文を書く。
## インターフェース
- 区分ごとのロジックを別クラスに分ける。
  - インターフェースを用いてポリモーフィズム（多態性 = 別のクラスを同じ型として扱えるようにする）を実現する。
  - クラス間は、互いを知らないほど良い。結合が弱くなり（独立性が高くなり）、変更による別クラスへの影響が減る。
## enum
- 列挙型（enum）を使い、区分定数の一覧を宣言する。
  - ポリモーフィズムは、区分の一覧がわかりにくいという問題があるため。
  - 区分オブジェクト：enumを使って区分ごとのロジックをわかりやすく整理する方法。
- Javaの場合、EnumSetで状態遷移表を表現できる。
:::message
- インターフェースを使い、使う側のクラスが区分ごとのクラスの影響を受けにくくする。
- enumを使い、業務で扱う区分の一覧を宣言することで、業務ロジックの見通しを良くし、わかりやすく整理する。
:::

# 3. 業務ロジックをわかりやすく整理する
## ドメインオブジェクト
### 業務ロジックを、データを持つクラスに集める
↑はオブジェクト指向の基本。
- 手続き型の設計：データクラス（データ構造）と機能クラス（処理手順）に分ける。
- オブジェクト指向：データとロジックを1つのクラスにまとめる。コードの重複や散在を防ぐ。

### メソッド
- **データを持つクラスのメソッドは、ロジックの置き場所**。
- インスタンス変数を返すだけの`getter`メソッドは(基本)書かない。
  こういうメソッドには何らかの計算/加工/判断をさせる任務を与えることを考える。
- メソッドはインスタンス変数を必ず使う。使わない場合はメソッド（ロジック）の置き場所を再検討すべき。

### クラス
- クラスが肥大化したら、**関連性の高いデータとロジックを抜き出して、新しいクラスに分ける**ことを考える。
- 凝集度が高いクラスを作ることが、オブジェクト指向の基本。
  独立性が高く、再利用性が高い。他のクラスへ影響を与えづらい（= 疎結合）。
  - 凝集：「切っても切れない」密接な関係。

### パッケージ
クラスの数が増えたときの整理の手段として、パッケージがある。
- 関連性の強いクラスは同じパッケージに集める。（= クラス郡を作る。）
- パッケージ内のクラスやメソッドのスコープは、できる限りパッケージ内に留める。（= publicにしない。）

:::message
オブジェクト指向の設計は、改善の繰り返し。
**コードを書いて動かしてみながら、改善を続け、より良い設計を見つけていく**。
:::

## ドメインモデル
- ドメインをモデリング（抽象化）したもの。
  （ドメインモデルを実装したものが、ドメインオブジェクト。）
- ドメインモデルを見れば、業務全体がどういった関心事から成り立っているのか理解できる。

## 3層 + ドメインモデル
業務ロジックはドメインモデルにのみ記述。
業務的な知識が必要な判断/加工/計算について、3層はドメインオブジェクトに任せる。
- 3層
  - プレゼンテーション層：外部との入出力。（UIなど）
  - アプリケーション層：マクロな手順。（業務フローなど）
  - データソース層：データの入出力。（データベースなど）
- ドメインモデル：業務データと業務ロジックを表現したドメインオブジェクトの集合。

:::message
ドメインモデルは業務の説明書。
:::

# 4. ドメインモデルの考え方で設計する
## ドメインモデルを開発する工程
- 分析：人間のやりたいことを正しく理解する
  - 要求の聞き取り
  - 不明点を確かめるための会話
  - 図や表を使っての整理
  - 理解した結果を記録する文書の作成
- 設計：人間のやりたいことをソフトウェアとして実現する方法を考える
  - パッケージ構成と名前
  - クラス構成と名前
  - メソッド構成と名前

:::message alert
#### よくある失敗
クラス名に、実際の業務に使われていない抽象的な言葉を使う。
:::

## ドメインモデルの作り方
#### 1. 部分を作りながら全体を組み立てていく
  ここの部品（ドメインオブジェクト）を作り、それを組み合わせながら全体を作っていく。
#### 2. 全体と部分を行ったり来たりしながら作る
  部分だけに目を向けず、全体として間違った方向に進んでいないか確認しながら。
  全体を俯瞰するためのツールとして、パッケージ図・業務フロー図がある。
#### 3. 重要な部分から作っていく
  重要な部分とは、間違いなく必要な部分。
  オブジェクトは独立性の高い部品なので、**単体として動作し、テストできる**。
#### 4. 独立した部品を組み合わせて、機能を実現する
  作ったドメインオブジェクトを組み合わせて、**アプリケーション層で機能を実現**。

## ドメインオブジェクトの見つけ方
業務の関心事を、**ヒト/モノ/コトに3分類**する。
  - ヒト：業務活動の当事者。行動する主体。
  - モノ：関心の対象。物理的なモノ + 概念的なモノ。
  - コト：事象。基本的に**ヒトの意思決定や行動の結果**。

**コトに注目して整理すると効果的**。
- コトは、**ヒトとモノとの関係**であるため、関心事を特定しやすくなる。
- コトは、**時間軸の前後関係**を持つため、全体の流れや重要な前後関係が明確になる。

