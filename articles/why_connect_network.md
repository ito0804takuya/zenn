---
title: "「ネットワークはなぜつながるのか」要点"
emoji: "📘"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["ネットワーク"]
published: false
---

# 目的
インフラ（特にネットワーク）の理解度を上げる。
そのために、下記書籍を読み、自分が理解したこと・要点を整理してメモする。

# 書籍
https://bookplus.nikkei.com/atcl/catalog/07/P83110/

### 目次
| 章 | 扱う範囲 |
| - | - |
| 第1章 | Webブラウザ |
| 第2章 | TCP/IP、LANドライバ（クライアント側） |
| 第3章 | ハブ、ルーター |
| 第4章 | 電話局、プロバイダ |
| 第5章 | ファイアウォール、キャッシュ・サーバー |
| 第6章 | LANドライバ、TCP/IP、Webサーバー・ソフト（クライアント側） |

（クライアント→サーバへの通信の流れに沿って記載している。）



# 第１章　Ｗｅｂブラウザがメッセージを作る―ブラウザ内部を探検

**ブラウザは**、入力されたURLに従って**リクエスト・メッセージを作り**、Webサーバーに送る。
ただし、**リクエストを送るのは**ブラウザ自身ではなく、**それを送る仕組み**（OSに組み込まれた*ネットワーク制御用ソフトウェア* = OSに組み込まれた**プロトコル・スタック**）**に依頼する**。

## 1.1 HTTPリクエスト・メッセージを作成する
URLのフォーマット（先頭からどの位置に、何を書くか）はプロトコル（HTTP, FTP, SMTPなど）によって異なる。
そのため、ブラウザがリクエスト・メッセージを作成するとき、最初に（使用するプロトコルに準じて）URLを解読する。
リクエスト・メッセージによって「どのサーバーに何をどうして欲しいのか」を伝える。

### <リクエスト・メッセージ>
| リクエスト・メッセージ内の位置 | 名称 | 説明 |
| - | - | - |
| 1行目 (1行) | リクエスト・ライン | `メソッド, URI, HTTPバージョン`の順に記載。<br>(例: `GET /items/3818 HTTP/1.1`) |
| 2行目 ~ 次の空行 | メッセージ・ヘッダー | リクエストの付加的な情報。<br>（詳細は本書と[このページ](https://developer.mozilla.org/ja/docs/Web/HTTP/Headers)を参照。） |
| 最後の行 (ブロック) | メッセージ・ボディ | サーバーに送信するデータ。 |

### <レスポンス・メッセージ>
| リクエスト・メッセージ内の位置 | 名称 | 説明 |
| - | - | - |
| 1行目 (1行) | ステータス・ライン | `HTTPバージョン, ステータス・コード, レスポンス・フレーズ`の順に記載。<br>(例: `HTTP/1.1 200 OK`) |
| 2行目 ~ 次の空行 | メッセージ・ヘッダー | リクエストの付加的な情報。 |
| 最後の行 (ブロック) | メッセージ・ボディ | サーバーからクライアントに送信するデータ。 |

## 1.2 WebサーバーのIPアドレスをDNSサーバーに問い合わせる
ブラウザが作成したリクエスト・メッセージをOS（→その先のプロトコル・スタック）に依頼する前に、ドメインメインからサーバーのIPアドレスを調べる必要がある。

### <TCP/IPにおけるネットワークの考え方>
```
ネットワーク = 小さなネットワークの集合 = 複数のサブネットが紐付いたルーター群
サブネット = ハブに何台かのPCが接続されたもの
```

### <IPアドレスの基本>
- ネットワーク番号 : どのネットワークなのか を表す。
- ホスト番号 : 上記ネットワークの中のどのホストなのか を表す。

下記2つは同じことを表現している。
`10.11.12.13/255.255.255.0`
`10.11.12.13/24`

この2つの表現の違うネットマスク（`255.255.255.0`, `24`）はいずれも`11111111.11111111.11111111.00000000`を表す。
そのため、ネットワーク番号は`10.11.12`で、ホスト番号は`13`。

### <DNS>
**DNS**は、ドメイン名をIPアドレスに変換する仕組み。（その逆も。）
（→ そうやって知ったIPアドレスを使って、リクエストの送信をプロトコル・スタックに依頼する。）

DNSを使ってIPアドレスを調べるには、DNSサーバーにドメイン名を渡して、そのレスポンスを受け取るだけ。
DNSサーバーに問い合わせるのは**DNSリゾルバ**。（**その実態はSocketライブラリの中の1部品**。DNSサーバーに対してクライアントとなるが、DNSクライアントではなくDNSリゾルバと呼ぶ。）

## 1.3 世界中のDNSサーバーが連携する

### <DNSサーバーの基本>
DNSサーバーへの問い合わせメッセージには下記3つの情報が含まれる。
- 名前 : 宛先のサーバーや、メール配送先（メルアドの@以降の名前）などの名前。
- クラス : `IN`という固定値。（理由は省略。）
- タイプ : 名前に対して紐付けられている情報の種類。
  - **A** : 名前と**IPアドレス**が紐付いている。
  - **MX** : 名前と**メール配信先**が紐付いている。
  - （NS 等、省略。）

この3つ（名前・クラス・タイプ）が一致するリソース・レコードの内容を返答する。
| 名前 | クラス | タイプ | クライアントに返答する内容 |
| - | - | - | - |
| www.testdomain.com | IN | A | 192.0.2.226 |
| testdomain.com | IN | MX | 10 mail.testdomain.com |
| ... | IN | ... | ... |

### <ドメインの階層>
ドメインは、右に位置するものが上位の階層。

`www.hoge.co.jp`の場合は、下記を意味する。
jp : 日本 を表す。
co : 日本国内のドメインの分類（企業） を表す。
hoge : その企業の **ドメイン** を表す。（これが主体！）
www : **サーバーの名前** を表す。

下位のドメインを担当するDNSサーバーは、その上位のDNSサーバーに登録されている。
（→ それが繰り返されて、最終的にルート・ドメイン`.`に辿り着く。）

また、`hoge.co.jp`**ドメインには**、`www.hoge.co.jp`や`stg.hoge.co.jp`、`dev.hoge.co.jp`**のようにサブドメインを登録できる**。

## 1.4 プロトコル・スタックにリクエスト・メッセージ送信を依頼する
WebブラウザがSocketライブラリを呼び出して、そのSocketライブラリがプロトコル・スタックに処理を依頼する。
（第2章は、この1.4項の内容をさらに詳細に解説している。）

### <Socketライブラリ>
Socketライブラリは、アプリケーション（ここではブラウザのこと）から、OSに組み込まれているネットワーク機能（プロトコル・スタック）を呼び出すためのプログラム群。
:::message
Socketライブラリはどこに存在するのか気になって調べた。
まだ理解が十分でないが、OSに組み込まれていると考えて良い模様。（[参考](http://tonetsutomu.com/tone/node/231)）
:::

### <データ送受信動作の概要>
#### データ送受信動作のイメージ
データを送受信するコンピュータ間にパイプのようなものがあり、そこをデータが流れる。
（パイプの端っこ（出入口）のことをソケットという。）
片側のソケットからデータを放り込むと、パイプの中を通ってもう片側のソケットからデータが出てくる。
そんなイメージ。

#### データ送受信動作のフェーズ
1. **ソケットを作る。**
  Socketライブラリの`socket`というプログラム部品を呼び出すだけ。
  （おそらくクライアント側の）ソケットの**ディスクリプタ**（識別子）が返ってくるので、それをメモリに記録。
  :::message
  プロトコル・スタック内部には制御情報（相手のIPアドレス、ポート番号、通信の進行状況など）を記録するメモリがある。**ソケットの実体は、その制御情報**。
  **プロトコル・スタックは、ソケットに記録された制御情報を参照しながら動く**。
  :::
  :::message
  `netstat`コマンドでソケットが一覧表示できる。
  :::

2. **クライアント側のソケットからサーバー側のソケットにパイプを伸ばして、つなぐ。**
  （パイプ = コネクション）

    下記3つの値を渡して、Socketライブラリの`connect`というプログラム部品を呼び出す。
    - *ディスクリプタ*
      1.のソケットのディスクリプタ。（相手とやり取りしているソケットがどれか、自分が記憶するため。）
    - *サーバーのIPアドレス*
      DNSで得たIPアドレス。（サーバーを特定するため。）
    - *サーバーのポート番号*
      ウェルノウンポートを指定。（サーバーの中で、そのやり取りにどのポート（= どのソケット）を使うか識別するため。）

    **クライアント側のソケットのポート番号はプロトコル・スタックが適当な値を割り当て**、接続動作を実行するときにサーバー側に通知される。
    相手と繋がったら、プロトコル・スタックは**相手のIPアドレスやポート番号などの情報をソケットに記録する**。

:::message
##### ディスクリプタとポート番号の違い
###### ディスクリプタ
1台のコンピュータの中で、ソケットを識別するために使う。
Socketライブラリから、ソケットを作るよう依頼したアプリケーションに渡すもの。（接続相手に渡すものじゃない。）

###### ポート番号
（そのコンピュータ自身でなく）接続相手側で、ソケットを識別するために使う。
クライアントがポート番号を指定することで、それを受け取ったサーバーは自身でソケットを特定できる。
:::

3. **データを送受信する。**
- HTTPリクエスト・メッセージ（送信データ）をメモリに用意し、そのデータとディスクリプタを指定して、Socketライブラリの`write`というプログラム部品を呼び出す。
- レスポンス・メッセージが返ってきたとき、Socketライブラリの`read`が受け取って、**受信バッファ**（受信したレスポンス・メッセージを格納するメモリ）に格納する。
（受信バッファはアプリケーション・プログラムの内部に用意したメモリなので、受信バッファに格納した時点でアプリケーションに渡したことになる。）

4. **パイプを外して、ソケットを抹消する。**
- ブラウザがデータを受信し終わると、Socketライブラリの`close`を呼び出して切断フェーズに入るようプロトコル・スタックに依頼。（パイプのが外れて）ソケットを抹消する。
- HTTPプロトコルでは本来、Webサーバー側から切断動作を実行することになっている。
しかし、多くの画像があるページなどの場合、接続・送受信・切断を都度繰り返すことになってしまい効率が悪いため、切断せずに複数のリクエスト/レスポンスのやり取りをする方法がHTTP 1.1からは用意された。その場合はリクエストすべきデータが無くなったところでブラウザから切断動作に入ることがある。



# 第２章　ＴＣＰ／ＩＰのデータを電気信号にして送る―プロトコル・スタックとＬＡＮアダプタを探検

ブラウザから依頼された**リクエスト・メッセージは、プロトコル・スタックがパケットの中に格納**して、さらに**宛先アドレスなどの制御情報を付加する**。
プロトコル・スタックは、そのパケットをLANアダプタに渡す。

LANアダプタは、プロトコル・スタックから渡されたパケットを**電気信号に変換**して、**LANケーブルに送り出す**。（→ネットワークの中に入る。）

### <プロトコル・スタック>
ネットワーク制御用ソフトウェアのこと。（*スタック = 積み重ね*）
色々な機能（通信エラー時にパケットを送り直す 等）を持っている。

### <LANアダプタ>
LANケーブルを差すところ。![](/images/why_connect_network/LAN-adapter.png)

（内容のうち、いくつかだけを上記1.4項に記載。その他は割愛。本書を読むこと。）



# 第３章　ケーブルの先はＬＡＮ機器だった―ハブとスイッチ、ルーターを探検
:::message alert
ここでは「クライアントPCは家庭や会社のLANに接続され、その先がブロードバンド回線（光ファイバー回線など）によってインターネットに接続されている」という典型的な状況に対して説明する。
:::

LANアダプタがLANケーブルに送信したパケットは、**スイッチング・ハブ**等を経由して**ルーター**に届く。

**ルーターの先はインターネット**なので、**そこから先はプロバイダがパケットを相手まで届けてくれる**。

（3.1、3.2項は割愛。）

## 3.3 ルーターのパケット中継動作
（この項も、内容のいくつかだけをかいつまんで記載。詳細は、本書を読むこと。）

### <ルーターの基本>
ルーターの内部構造は、中継部分とポート部分に分かれる。
- 中継部分
  ルーティングテーブルに登録された情報によって中継先を判断してパケットを中継する。
- ポート部分
  パケットを送り出す部分。（ADSL用、FTTH用、無線LAN、イーサネット用など各種対応したもの。）

### <ルーティングテーブルに登録される情報>
ルーティングテーブル（経路表）には下記のような情報を登録する。
- **宛先**
  ルーターの背後にあるサブネット自体を指定する。（つまり、ネットワーク番号部だけに値が入って、ホスト部は全て`0`になっているIPアドレス。）
- ネットマスク
  （[宛先]を示すのに必要。）
  :::message
  #### アドレス集約
  サブネットを複数集めて1つのサブネットとみなして、ひとまとめのサブネットを登録するという方法（考え方）。正しく中継しながら、1つずつ登録しなくて済む。

  例えば、`10.1.0.1/24`, `10.1.0.2/24`, `10.1.0.3/24`というサブネットをそれぞれ登録するのでなく、`10.1.0.0/16`を登録する。
  :::
  :::message
  #### デフォルト・ゲートウェイ
  ネットマスク欄がすべて0（`0.0.0.0`）となっている行は、デフォルト経路を表す。
  これによって、「該当する行が無くてパケットの行き先が不明」となることを防いでいる。
  この行に登録したルーターをデフォルト・ゲートウェイという。
  :::
- ゲートウェイ
  中継するルーター の IPアドレスのこと。
- インターフェース
  中継するルーター の ポート番号のこと。
- メトリック
  目的地への近さを示す数値。

## 3.4 ルーターの付加機能
- アドレス変換
- パケット・フィルタリング

### <アドレス変換>
#### アドレス変換でIPアドレスを有効活用
IPアドレスの枯渇に対して、**アドレス変換**によって解決している。

ネットワークが独立していれば、2つのネットワーク内で同じアドレスを使っていても問題ない。
つまり、A社内（1つ）のネットワーク内の機器に割り当てるアドレスは、世界で1つのアドレスでなくても良い。

そうやってA社が**社内用に使うアドレスの範囲**に対して、全ての範囲に対してみんなが勝手に使うのではなく、ある程度決められた範囲にしておこうというルールが設けられた。それが**プライベート・アドレス**。
- 10.0.0.0 ~ 10.255.255.255
- 172.16.0.0 ~ 172.31.255.255
- 192.168.0.0 ~ 192.168.255.255

そして、**従来の固有なアドレス**（世界で一意なアドレス）は**グローバル・アドレス**と呼ぶことになった。

#### アドレス変換の基本動作
**パケットを中継するときに、IPアドレスとポート番号を書き換える**というのがアドレス変換の仕組み。

例えば、ある社内のネットワーク内のホスト（送信元）からインターネットへのアクセスの場合は下記のようになる。
1. **送信元のIPアドレスはプライベート・アドレス**だが、**ルーターを経由する際にそれをグローバル・アドレスに書き換える**。
  （**ここで使うグローバル・アドレスはアドレス変換装置（ルーター）のインターネット側のポートに割り当てられたアドレス**。）
2. 「**書き換える前**のプライベート・アドレスとポート番号」、「**書き換えた後**のグローバル・アドレスとポート番号」を1セットにしてアドレス変換装置内の**対応表に記録する**。
3. サーバーからはグローバル・アドレスに対して返答があるため、それを受け取ったルーターがプライベート・アドレスに変換して、送信元にパケットを送る。

こうすることで、プライベート・アドレスを割り当てた機器もインターネットにアクセスできる。

また、**インターネット側から見ると、アドレス変換装置（ここではルーター）が通信相手になっている**ように見える。
インターネットから社内にパケットを中継するときは、対応表に登録されていないと中継できない。つまり、**インターネットにアクセスしていない（通じていない）機器に対して、インターネット側から社内にパケットを送ることができない**ということ。これは**不正侵入を防ぐ**効果を持つ。

:::message alert
ここの内容は重要。
:::

:::message
AWSで、インターネット→ALB→プライベートサブネットとアクセスできるように設定することがある。これはつまり、上記のようなことをAWSリソースで行っているのだと実感した。
:::
https://aws.amazon.com/jp/premiumsupport/knowledge-center/public-load-balancer-private-ec2/



# 第４章　アクセス回線を通ってインターネットの内部へ―アクセス回線とプロバイダを探検
**ルーターの先のインターネット内部の話**。
インターネットの入り口にはアクセス回線（電話回線、ISDN、ADSL、専用線など）という通信回線があり、契約しているプロバイダに繋がっている。そこにはPOPというプロバイダ向けのルーターがある。
POPは最寄りの郵便局のようなもの。アクセス回線でPOPまでパケットを運んで、（POPを経由して）そこから全世界に向けて配送される。POPの先がインターネットの中核部分と言える。

（割愛）



# 第５章　サーバー側のＬＡＮには何がある
Webサーバー側のLANにたどり着くと、下記がある（かもしれない）。
- ファイアウォール : パケットをチェックする。
- キャッシュ・サーバー : 望むデータがそこにあればそこから返却する。
- 負荷分散装置 : 複数のサーバーに振り分ける。
- コンテンツ配信サービス : インターネット全体にキャッシュ・サーバーを分散する。

## 5.1 Webサーバーの設置場所
（Webサーバーがあったりする）公開しているネットワークや、（社内LANがあったりする）非公開のネットワークの前段に、ファイアウォールを設置することが多い。
ファイアウォールによって、特定のサーバー上で動く特定のアプリケーションにアクセスするパケットだけを通し、それ以外は遮断する。
そのアプリケーションにセキュリティホールがあればそこから攻撃される危険性は残るが、特定の場所のみに遮断する前（ファイアウォール設置前）の状況に比べて危険性は低くなる。

## 5.2 ファイアウォールの仕組みと働き
ファイアウォールが不正侵入を防ぐ仕組みとしては、パケット・フィルタリング型が主流。

### <パケット・フィルタリング>
（ルーターが）パケットを中継するときに、**MACヘッダー、IPヘッダー、TCPヘッダーの記載内容**（本書P338）を調べて、それが事前に**設定した条件に合致したら、そのパケットを破棄する**。

**アプリケーションを限定するときには、宛先のポート番号を条件に加える**。（AWS セキュリティグループと同じように）

負担が大きい処理（複雑な条件設定や破棄したパケットの記録など）が不要な場合は、専用の機器でなく、ルーターをファイアウォールとして使うこともできる。
（パケット・フィルタリングはルーターのパケット中継機能の付加機能のようなもの。）

## 5.3 複数サーバーにリクエストを振り分けてサーバーの負荷を分散

### <ラウンドロビン>
DNSのラウンドロビンは、DNSに登録されているIPアドレス（Webサーバー）を問い合わせのたびに順番に回答するという仕組み。

複数のサーバーに振り分けることはできるが、そのサーバーが故障していてもお構いなしに振り分けてしまう。
まら、連続的なやり取りが必要なページだと、途中でそのやり取りが途切れてしまう。

そういった不都合を避けるための機器がロードバランサー。

### <ロードバランサー（負荷分散装置）>
使うときは、Webサーバーの代わりにロードバランサーをDNSに登録する。

各Webサーバーの負荷状況を元に、負荷が低いサーバーにリクエストを転送する。

HTTPの仕様はステートレスなのでそのままではやり取りの前後関係を判断できない。なので、HTTPの仕様を拡張し、**Cookie**をヘッダーに付け加えて渡すことで、ロードバランサーがやり取りの前後関係を判断できるようにする。

## 5.4 キャッシュ・サーバーを理由したサーバーの負荷分散

キャッシュ・サーバーとは、**プロキシ**という仕組みを使って**データをキャッシュする**サーバー。

**プロキシとは、Webサーバーとクライアントの間に入って、Webサーバーへのアクセスを仲介する**役割を持つ。
**Webサーバーから受け取ったデータをディスクに保存しておいて、再度そのデータの要求があったときには、Webサーバーに代わってそのデータをクライアントに返す機能**を持つ。
なのでその分、Webサーバーの負荷が軽減する。

使うときは、Webサーバーの代わりにキャッシュ・サーバーをDNSに登録する。

データの更新があるかどうか（= 最新データを取りにいかないといけないか）は、キャッシュ・サーバーからWebサーバーへリクエストを転送する際に付与する`If-Modified-Since`ヘッダーをWebサーバーが見て、データの最終更新日と照らし合わせて判断する。

### <プロキシの種類>
#### フォワード・プロキシ
クライアント側にプロキシが置かれた状態。**クライアントを代表して、フォワード・プロキシがWebサーバーにリクエストする**。
Webブラウザに設定が必要。あまり使われない。

#### リバース・プロキシ
Webサーバーの前段に置かれ、**Webサーバーを代表して各クライアントにレスポンスする**。
キャッシュ・サーバーで採用している方式。

# 第６章　Ｗｅｂサーバーに到着し、応答データがＷｅｂブラウザに戻る―わずか数秒の「長い旅」の終わり
パケットが`Webサーバー`に到達すると、プロトコル・スタックがパケットの中身を取り出して元のリクエスト・メッセージを復元して、`Webサーバー・アプリケーション`に渡す。
Webサーバー・アプリケーションはリクエスト・メッセージの内容に従ってデータをレスポンス・メッセージに入れて送り返す。

以上