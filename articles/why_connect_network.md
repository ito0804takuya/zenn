---
title: "「ネットワークはなぜつながるのか」要点"
emoji: "📘"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["ネットワーク"]
published: false
---

# 目的
インフラ（特にネットワーク）の理解度を上げる。

そのために、下記書籍を読み、自分が理解したこと・要点を整理してメモする。

# 書籍
https://bookplus.nikkei.com/atcl/catalog/07/P83110/

### 目次
| 章 | 扱う範囲 |
| - | - |
| 第1章 | Webブラウザ |
| 第2章 | TCP/IP、LANドライバ（クライアント側） |
| 第3章 | ハブ、ルーター |
| 第4章 | 電話局、プロバイダ |
| 第5章 | ファイアウォール、キャッシュ・サーバー |
| 第6章 | LANドライバ、TCP/IP、Webサーバー・ソフト（クライアント側） |

（クライアント→サーバへの通信の流れに沿って記載している。）



# 第１章　Ｗｅｂブラウザがメッセージを作る―ブラウザ内部を探検

**ブラウザは**、入力されたURLに従って**リクエスト・メッセージを作り**、Webサーバーに送る。
ただし、**リクエストを送るのは**ブラウザ自身ではなく、**それを送る仕組み**（OSに組み込まれた*ネットワーク制御用ソフトウェア* = OSに組み込まれた**プロトコル・スタック**）**に依頼する**。

## 1.1 HTTPリクエスト・メッセージを作成する
URLのフォーマット（先頭からどの位置に、何を書くか）はプロトコル（HTTP, FTP, SMTPなど）によって異なる。
そのため、ブラウザがリクエスト・メッセージを作成するとき、最初に（使用するプロトコルに準じて）URLを解読する。
リクエスト・メッセージによって「どのサーバーに何をどうして欲しいのか」を伝える。

### <リクエスト・メッセージ>
| リクエスト・メッセージ内の位置 | 名称 | 説明 |
| - | - | - |
| 1行目 (1行) | リクエスト・ライン | `メソッド, URI, HTTPバージョン`の順に記載。<br>(例: `GET /items/3818 HTTP/1.1`) |
| 2行目 ~ 次の空行 | メッセージ・ヘッダー | リクエストの付加的な情報。<br>（詳細は本書と[このページ](https://developer.mozilla.org/ja/docs/Web/HTTP/Headers)を参照。） |
| 最後の行 (ブロック) | メッセージ・ボディ | サーバーに送信するデータ。 |

### <レスポンス・メッセージ>
| リクエスト・メッセージ内の位置 | 名称 | 説明 |
| - | - | - |
| 1行目 (1行) | ステータス・ライン | `HTTPバージョン, ステータス・コード, レスポンス・フレーズ`の順に記載。<br>(例: `HTTP/1.1 200 OK`) |
| 2行目 ~ 次の空行 | メッセージ・ヘッダー | リクエストの付加的な情報。 |
| 最後の行 (ブロック) | メッセージ・ボディ | サーバーからクライアントに送信するデータ。 |

## 1.2 WebサーバーのIPアドレスをDNSサーバーに問い合わせる
ブラウザが作成したリクエスト・メッセージをOS（→その先のプロトコル・スタック）に依頼する前に、ドメインメインからサーバーのIPアドレスを調べる必要がある。

### <TCP/IPにおけるネットワークの考え方>
```
ネットワーク = 小さなネットワークの集合 = 複数のサブネットが紐付いたルーター群
サブネット = ハブに何台かのPCが接続されたもの
```

### <IPアドレスの基本>
- ネットワーク番号 : どのネットワークなのか を表す。
- ホスト番号 : 上記ネットワークの中のどのホストなのか を表す。

下記2つは同じことを表現している。
`10.11.12.13/255.255.255.0`
`10.11.12.13/24`

この2つの表現の違うネットマスク（`255.255.255.0`, `24`）はいずれも`11111111.11111111.11111111.00000000`を表す。
そのため、ネットワーク番号は`10.11.12`で、ホスト番号は`13`。

### <DNS>
**DNS**は、ドメイン名をIPアドレスに変換する仕組み。（その逆も。）
（→ そうやって知ったIPアドレスを使って、リクエストの送信をプロトコル・スタックに依頼する。）

DNSを使ってIPアドレスを調べるには、DNSサーバーにドメイン名を渡して、そのレスポンスを受け取るだけ。
DNSサーバーに問い合わせるのは**DNSリゾルバ**。（**その実態はSocketライブラリの中の1部品**。DNSサーバーに対してクライアントとなるが、DNSクライアントではなくDNSリゾルバと呼ぶ。）

## 1.3 世界中のDNSサーバーが連携する

### <DNSサーバーの基本>
DNSサーバーへの問い合わせメッセージには下記3つの情報が含まれる。
- 名前 : 宛先のサーバーや、メール配送先（メルアドの@以降の名前）などの名前。
- クラス : `IN`という固定値。（理由は省略。）
- タイプ : 名前に対して紐付けられている情報の種類。
  - **A** : 名前と**IPアドレス**が紐付いている。
  - **MX** : 名前と**メール配信先**が紐付いている。
  - （NS 等、省略。）

この3つ（名前・クラス・タイプ）が一致するリソース・レコードの内容を返答する。
| 名前 | クラス | タイプ | クライアントに返答する内容 |
| - | - | - | - |
| www.testdomain.com | IN | A | 192.0.2.226 |
| testdomain.com | IN | MX | 10 mail.testdomain.com |
| ... | IN | ... | ... |

### <ドメインの階層>
ドメインは、右に位置するものが上位の階層。

`www.hoge.co.jp`の場合は、下記を意味する。
jp : 日本 を表す。
co : 日本国内のドメインの分類（企業） を表す。
hoge : その企業の **ドメイン** を表す。（これが主体！）
www : **サーバーの名前** を表す。

下位のドメインを担当するDNSサーバーには、その上位のDNSサーバーを登録されている。
（→ それが繰り返されて、最終的にルート・ドメイン`.`に辿り着く。）

また、`hoge.co.jp`**ドメインには**、`www.hoge.co.jp`や`stg.hoge.co.jp`、`dev.hoge.co.jp`**のようにサブドメインを登録できる**。

## 1.4 プロトコル・スタックにリクエスト・メッセージ送信を依頼する
WebブラウザがSocketライブラリを呼び出して、そのSocketライブラリがプロトコル・スタックに処理を依頼する。
（第2章は、この1.4項の内容をさらに詳細に解説している。）

### <Socketライブラリ>
Socketライブラリは、アプリケーション（ここではブラウザのこと）から、OSに組み込まれているネットワーク機能（プロトコル・スタック）を呼び出すためのプログラム群。
:::message
Socketライブラリはどこに存在するのか気になって調べた。
まだ理解が十分でないが、OSに組み込まれていると考えて良い模様。（[参考](http://tonetsutomu.com/tone/node/231)）
:::

### <データ送受信動作の概要>
#### データ送受信動作のイメージ
データを送受信するコンピュータ間にパイプのようなものがあり、そこをデータが流れる。
（パイプの端っこ（出入口）のことをソケットという。）
片側のソケットからデータを放り込むと、パイプの中を通ってもう片側のソケットからデータが出てくる。
そんなイメージ。

#### データ送受信動作のフェーズ
1. **ソケットを作る。**
  Socketライブラリの`socket`というプログラム部品を呼び出すだけ。
  （おそらくクライアント側の）ソケットの**ディスクリプタ**（識別子）が返ってくるので、それをメモリに記録。
  :::message
  プロトコル・スタック内部には制御情報（相手のIPアドレス、ポート番号、通信の進行状況など）を記録するメモリがある。**ソケットの実体は、その制御情報**。
  **プロトコル・スタックは、ソケットに記録された制御情報を参照しながら動く**。
  :::
  :::message
  `netstat`コマンドでソケットが一覧表示できる。
  :::

2. **クライアント側のソケットからサーバー側のソケットにパイプを伸ばして、つなぐ。**
  （パイプ = コネクション）

    下記3つの値を渡して、Socketライブラリの`connect`というプログラム部品を呼び出す。
    - *ディスクリプタ* : 1.のソケットのディスクリプタ。（相手とやり取りしているソケットがどれか、自分が記憶するため。）
    - *サーバーのIPアドレス* : DNSで得たIPアドレス。（サーバーを特定するため。）
    - *サーバーのポート番号* : ウェルノウンポートを指定。（サーバーの中で、そのやり取りにどのポート（= どのソケット）を使うか識別するため。）

    **クライアント側のソケットのポート番号はプロトコル・スタックが適当な値を割り当て**、接続動作を実行するときにサーバー側に通知される。
    相手と繋がったら、プロトコル・スタックは**相手のIPアドレスやポート番号などの情報をソケットに記録する**。

:::message
##### ディスクリプタとポート番号の違い
###### ディスクリプタ
1台のコンピュータの中で、ソケットを識別するために使う。
Socketライブラリから、ソケットを作るよう依頼したアプリケーションに渡すもの。（接続相手に渡すものじゃない。）

###### ポート番号
（そのコンピュータ自身でなく）接続相手側で、ソケットを識別するために使う。
クライアントがポート番号を指定することで、それを受け取ったサーバーは自身でソケットを特定できる。
:::

3. **データを送受信する。**
- HTTPリクエスト・メッセージ（送信データ）をメモリに用意し、そのデータとディスクリプタを指定して、Socketライブラリの`write`というプログラム部品を呼び出す。
- レスポンス・メッセージが返ってきたとき、Socketライブラリの`read`が受け取って、**受信バッファ**（受信したレスポンス・メッセージを格納するメモリ）に格納する。
（受信バッファはアプリケーション・プログラムの内部に用意したメモリなので、受信バッファに格納した時点でアプリケーションに渡したことになる。）

4. **パイプを外して、ソケットを抹消する。**
- ブラウザがデータを受信し終わると、Socketライブラリの`close`を呼び出して切断フェーズに入るようプロトコル・スタックに依頼。（パイプのが外れて）ソケットを抹消する。
- HTTPプロトコルでは本来、Webサーバー側から切断動作を実行することになっている。
しかし、多くの画像があるページなどの場合、接続・送受信・切断を都度繰り返すことになってしまい効率が悪いため、切断せずに複数のリクエスト/レスポンスのやり取りをする方法がHTTP 1.1からは用意された。その場合はリクエストすべきデータが無くなったところでブラウザから切断動作に入ることがある。



# 第２章　ＴＣＰ／ＩＰのデータを電気信号にして送る―プロトコル・スタックとＬＡＮアダプタを探検

ブラウザから依頼された**リクエスト・メッセージは、プロトコル・スタックがパケットの中に格納**して、さらに**宛先アドレスなどの制御情報を付加する**。
プロトコル・スタックは、そのパケットをLANアダプタに渡す。

LANアダプタは、プロトコル・スタックから渡されたパケットを**電気信号に変換**して、**LANケーブルに送り出す**。（→ネットワークの中に入る。）

### プロトコル・スタック
ネットワーク制御用ソフトウェアのこと。（*スタック = 積み重ね*）
色々な機能（通信エラー時にパケットを送り直す 等）を持っている。

### LANアダプタ
LANケーブルを差すところ。![](/images/why_connect_network/LAN-adapter.png)

（割愛）



# 第３章　ケーブルの先はＬＡＮ機器だった―ハブとスイッチ、ルーターを探検
:::message alert
ここでは「クライアントPCは家庭や会社のLANに接続され、その先がブロードバンド回線（光ファイバー回線など）によってインターネットに接続されている」という典型的な状況に対して説明する。
:::

LANアダプタがLANケーブルに送信したパケットは、**スイッチング・ハブ**等を経由して**ルーター**に届く。

**ルーターの先はインターネット**なので、**そこから先はプロバイダがパケットを相手まで届けてくれる**。

（割愛）



# 第４章　アクセス回線を通ってインターネットの内部へ―アクセス回線とプロバイダを探検
**ルーターの先のインターネット内部の話**。
インターネットの入り口にはアクセス回線（電話回線、ISDN、ADSL、専用線など）という通信回線があり、契約しているプロバイダに繋がっている。そこにはPOPというプロバイダ向けのルーターがある。
POPは最寄りの郵便局のようなもの。アクセス回線でPOPまでパケットを運んで、（POPを経由して）そこから全世界に向けて配送される。POPの先がインターネットの中核部分と言える。

（割愛）



# 第５章　サーバー側のＬＡＮには何がある
Webサーバー側のLANにたどり着くと、下記がある（かもしれない）。
- ファイアウォール : パケットをチェックする。
- キャッシュ・サーバー : 望むデータがそこにあればそこから返却する。
- 負荷分散装置 : 複数のサーバーに振り分ける。
- コンテンツ配信サービス : インターネット全体にキャッシュ・サーバーを分散する。


# 第６章　Ｗｅｂサーバーに到着し、応答データがＷｅｂブラウザに戻る―わずか数秒の「長い旅」の終わり
パケットが`Webサーバー`に到達すると、プロトコル・スタックがパケットの中身を取り出して元のリクエスト・メッセージを復元して、`Webサーバー・アプリケーション`に渡す。
Webサーバー・アプリケーションはリクエスト・メッセージの内容に従ってデータをレスポンス・メッセージに入れて送り返す。

以上