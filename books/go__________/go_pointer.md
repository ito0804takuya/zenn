---
title: "Go_ポインタ"
---

# ポインタ

## なぜポインタを使うか

値を関数に渡すとき、**その関数内での変更は、呼び出し元に影響を与えない**。

:::message
**Go は"値渡し"の言語**。
つまり、関数に値を渡すたびに、Go がその値を受け取って**ローカルコピー(メモリ内の新しい変数)を作成**する。
:::

```go
func main() {
  first := "ジョン"
  updateName(first) // 名前を更新したはずが...
  println(first) // ジョン
}

func updateName(name string) {
  name = "田中"
}
```

updateName 関数で行う変更を main 関数の first 変数にも反映させるには、ポインタを使用する。
**ポインタで、値ではなくメモリアドレスを渡すことで、呼び出し元にも反映される**。

## ポインタとは

**変数のメモリアドレス**を示すもの。

### &演算子

変数の前に`&`を書くことで、その変数の（オブジェクトの）**アドレス**を取得する。

### \*演算子

ポインタを逆参照する。つまり、ポインタに格納されたアドレスにあるオブジェクト（ポインタが指す値）へアクセスする。

:::message

- **変数**の前に`*`を書くと、その変数が指しているアドレスに格納されている**オブジェクトの値**を取得する。これを逆参照（dereferencing）と呼ぶ。

- **型名**の前に`*`を書くと、**その型の値を格納しているポインタ**であることを宣言する。（**ポインタ型**）

:::

```go
func main() {
  first := "ジョン"
  updateName(&first) // ポインタ(メモリアドレス)を渡す
  println(first) // 田中 と出力される
}

func updateName(name *string) { // stringを格納しているポインタ
  *name = "田中" // ポインタ先の文字列をupdate
}
```

:::message
### ポインタ型

ポインタ型のゼロ値は`nil`。


例えば`int`と`nil`を取りうる値の変数を定義したければ、intのポインタ型（`*int`）を使う。
ただし、`nil`のポインタ型の変数（メモリアドレスがどこも指していない）に、*演算子でアドレス先の値にアクセスしようとすると、ヌルポでエラーになる。
なので、その場合は変数がnilでないことを確認してから*演算子でアクセスする。

```go
var i *int
fmt.Println(i)  // nil
fmt.Println(*i) // i（アドレス）がnilなので、*iはアクセスがそもそもできなく、エラーになる

w := 2
i = &w
fmt.Println(i, *i) // 0x140000180a8 2

i = nil
fmt.Println(i) // nil
```
:::