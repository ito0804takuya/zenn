---
title: "Go_複合型（コンポジット型）"
---

複数の要素を持つ型。配列、スライス、マップが該当。

# 配列 : `[n]T`

特定の同じ型の、**固定長**のデータ構造。
**宣言または初期化するときにサイズ（要素数）の定義が必要**。また、**作成後にサイズを変更することができない**。
これにより、配列は Go プログラムでは一般に使用されないが、スライスとマップの基盤となっている。

## 初期化方法

- 空の箱だけ作る（値は指定しない）場合。

  ```go
  var arr [3]int // [0 0 0]
  ```

  ↓ でもできるんだが、スライスのときは基本的には ↑ の書き方をしたほうが良いので、配列も ↑ で覚えておく。

  ```go:使わない
  arr := [3]int{}
  ```

- 値をセットして初期化する場合。

  ```go
  arr := [3]int{10, 20} // [10 20 0]
  ```

- 要素数がわからない場合。

  ```go
  arr := [...]int{ ???? }
  ```

- 指定の位置だけ、値をセットする方法。
  ```go
  arr := [...]int{1: 30, 4: 20} // [0 30 0 0 20]
  ```

## 操作

- アクセス : `arr[i]`
- 長さ : `len(arr)`
- スライス演算 : `arr[2:5]`
  配列からスライスを作る。この例だと`arr[2] から arr[5-1] まで`を抽出したものになる。（`arr[5]`まで ではないので注意!）
  ```go:スライス演算
  arr := [...]string{"a", "b", "c", "d", "e", "f"}
  fmt.Println(arr[2:5]) // [c d e]
  ```

## 2 次元配列

```go:2次元配列
func main() {
  var twoD [3][5]int

  for i := 0; i < 3; i++ {
    for j := 0; j < 5; j++ {
      twoD[i][j] = (i + 1) * (j + 1)
    }
    fmt.Println("Row", i, ":", twoD[i])
  }
  fmt.Println(twoD)
}
/*
  Row 0 : [1 2 3 4 5]
  Row 1 : [2 4 6 8 10]
  Row 2 : [3 6 9 12 15]
  [[1 2 3 4 5] [2 4 6 8 10] [3 6 9 12 15]]
/*
```
